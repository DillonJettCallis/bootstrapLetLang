import this/Lexer.Position

import this/Ast.AccessModifier
import this/Ast.Public
import this/Ast.Protected
import this/Ast.Internal
import this/Ast.Private

import this/Ast.NullLiteralExp
import this/Ast.BooleanLiteralExp
import this/Ast.NumberLiteralExp
import this/Ast.StringLiteralExp
import this/Ast.ListLiteralExp
import this/Ast.CharLiteralExp
import this/Ast.IdentifierExp
import this/Ast.BinaryOpExp
import this/Ast.UnaryOpExp
import this/Ast.BlockExp
import this/Ast.CallExp
import this/Ast.LambdaExp
import this/Ast.IfExp
import this/Ast.ReturnExp
import this/Ast.ThrowExp
import this/Ast.ConstructExp
import this/Ast.ConstructTupleExp
import this/Ast.MatchExp
import this/Ast.Expression
import this/Ast.Statement
import this/Ast.ExpressionStatement
import this/Ast.AssignmentStatement
import this/Ast.FunctionStatement
import this/Ast.TypeStatement
import this/Ast.ImportStatement
import this/Ast.DeconstructDataStatement
import this/Ast.DeconstructTupleStatement
import this/Ast.DebuggerStatement
import this/Ast.Declaration
import this/Ast.AtomDeclare
import this/Ast.DataDeclare
import this/Ast.TypeDeclare
import this/Ast.FunctionDeclare
import this/Ast.ImportDeclare
import this/Ast.ConstantDeclare
import this/Ast.ProtocolDeclare
import this/Ast.ImplDeclare
import this/Ast.MatchPattern
import this/Ast.AstModule
import this/Ast.AstFile

import this/Type.PrimitiveType
import this/Type.AtomType
import this/Type.DataType
import this/Type.ConstructorType
import this/Type.ProtocolType
import this/Type.FunctionType
import this/Type.TupleType
import this/Type.GenericType
import this/Type.UnknownType
import this/Type.NamedType
import this/Type.QualifiedType
import this/Type.PlaceholderType
import this/Type.UnionType
import this/Type.IntersectionType
import this/Type.CharType
import this/Type.StringType
import this/Type.IntType
import this/Type.FloatType
import this/Type.BooleanType
import this/Type.AnyType
import this/Type.NullType
import this/Type.UnitType
import this/Type.NothingType
import this/Type.ListType
import this/Type.MapType
import this/Type.VarArgsType
import this/Type.Type

import this/CoreLib.initCoreScope

private data DependencyScope = {
  values: Map[String, Type]
}

private data ModuleScope = {
  deps: Map[(String, String), DependencyScope],
  files: Map[String, (AstFile, Scope)]
}

data FunctionSignature = {
  isStatic: Boolean,          // is this a static function?
  name: String,               // the name of this method
  type: Type // the fully qualified function type
}

data MethodMap = {
  // map the method signature to the full location of the method.
  // This DOES include protocol implementations for this type
  // Protocol impls are merged into here AND go into their own protocol map
  methods: Map[FunctionSignature, QualifiedType]
}

data ProtocolImplPair = {
  // A pair of the protocol and the implementation type. Used as a key in maps
  proto: QualifiedType,
  base: QualifiedType
}

data Scope = {
  parent: Scope,
  types: Map[String, Type],
  values: Map[String, Type],
  methods: Map[QualifiedType, MethodMap],
  protocols: Map[QualifiedType, List[FunctionSignature]],
  protocolImpls: Map[ProtocolImplPair, MethodMap]
}

implement Scope {

  fun new(): Scope = Scope {
    parent: null,
    types: Map.of(),
    values: Map.of(),
    methods: Map.of(),
    protocols: Map.of(),
    protocolImpls: Map.of()
  }

  fun child(this): Scope = {
    val base = Scope.new();
    base { parent: this }
  }

  fun setType(this, name: String, value: Type): Scope = this{ types: this.types.set(name, value) }
  fun getType(this, name: String): Type = {
    val mine = this.types.get(name);

    if (mine == null) {
      if (this.parent == null) {
        return null
      } else {
        return this.parent.getType(name)
      }
    } else {
      return mine
    }
  }

  fun setValue(this, name: String, value: Type): Scope = this{ values: this.values.set(name, value) }
  fun getValue(this, name: String): Type = {
    val mine = this.values.get(name);

    if (mine == null) {
      if (this.parent == null) {
        return null
      } else {
        return this.parent.getValue(name)
      }
    } else {
      return mine
    }
  }

  fun setMethod(this, base: QualifiedType, sig: FunctionSignature, impl: QualifiedType): Scope = {
    val existingMap = this.methods.get(base)

    val methods = {
      if (existingMap == null) {
        Map.of()
      } else {
        existingMap.methods
      }
    }.set(sig, impl);

    val methods = this.methods.set(base, MethodMap{ methods });

    return this{methods};
  }

  fun resolveName(this, init: Type, pos: Position): Type = {
    match (init) {
      _ when init is NamedType => {
        val byName = this.getType(init.name)

        if (byName == null) {
          pos.fail("Could not find type with name ${init.name} in scope")
        }

        byName
      }
      _ when init is DataType => {
        // child scope with generic types
        val childScope = init.typeParams.fold(this.child(), { sum, next =>
          sum.setType(next.name, next)
        })

        val mappedFields = init.fields.entries().map({ entry =>
          val (name, value) = entry;
          val mappedType = childScope.resolveName(value, pos);
          return (name, mappedType);
        });

        init { fields: Map.from(mappedFields) };
      }
      _ when init is ConstructorType => ConstructorType{ base: resolveName(init.base, pos) }
      _ when init is ProtocolType => pos.fail("Protocol types are not yet supported")
      _ when init is FunctionType => {
        // child scope with generic types
        val childScope = init.typeParams.fold(this.child(), { sum, next =>
          sum.setType(next.name, next)
        })

        val paramTypes = init.paramTypes.map({ value =>
          childScope.resolveName(value, pos)
        });

        val resultType = childScope.resolveName(init.resultType, pos);

        init { paramTypes, resultType }
      }
      _ when init is VarArgsType => VarArgsType { base: this.resolveName(init.base, pos) }
      _ when init is TupleType => TupleType { paramTypes: init.paramTypes.map({raw => this.resolveName(raw, pos)}) }
      _ when init is UnionType => UnionType { paramTypes: init.paramTypes.map({raw => this.resolveName(raw, pos)}) }
      _ when init is IntersectionType => IntersectionType { paramTypes: init.paramTypes.map({raw => this.resolveName(raw, pos)}) }
      _ when init is GenericType => GenericType{
        base: this.resolveName(init.base, pos),
        paramTypes: init.paramTypes.map({raw => this.resolveName(raw, pos)})
      }
      _ => init
    }
  }
}

fun checkModule(module: AstModule): List[Scope] = {
  val core = initCoreScope();

  module.files.entries().map({ entry =>
    val (path, astFile) = entry;

    buildFileScope(core, path.last(), astFile, false)
  })
}

private fun buildFileScope(core: Scope, basePath: String, file: AstFile, includePrivate: Boolean): Scope = {
  fun qualified(name: String): Scope = {
    return QualifiedType { org: 'this', module: 'this', path: "$basePath.$name" };
  }

  fun qualifiedType(scope: Scope, name: String): Scope = {
    return scope.setType(name, qualified(name));
  }

  fun buildTypes(includePrivate: Boolean): Scope = {
    // contains all the TYPES that are in scope, not the VALUES
    return file.declarations.fold(core.child(), { sum, next =>

      if ( {!includePrivate} && next.access == Private) {
        return sum;
      }

      match (next) {
        _ when next is AtomDeclare => qualifiedType(sum, next.name)
        _ when next is DataDeclare => qualifiedType(sum, next.name)
        _ when next is TypeDeclare => qualifiedType(sum, next.type.name)
        _ when next is ImportDeclare => {
          val {org, module, path, name} = next.statement;
          sum.setType(name, QualifiedType { org, module, path } );
        }
        _ when next is ProtocolDeclare => next.pos.fail("Protocols are not implemented yet")
        _ => sum
      }
    });
  };

  val lookup = buildTypes(true);
  val names = if (includePrivate) {
    lookup
  } else {
    buildTypes(includePrivate);
  };

  // set up all the VALUES now
  file.declarations.fold(names, { sum, next =>
    if ( {!includePrivate} && next.access == Private) {
      return sum;
    }

    match (next) {
      _ when next is AtomDeclare => sum.setValue(next.name, lookup.getType(next.name))
      _ when next is DataDeclare => sum.setValue(next.name, ConstructorType{ base: lookup.getType(next.name) })
      _ when next is FunctionDeclare => sum.setValue(next.func.name, lookup.resolveName( next.func.body.type, next.pos ))
      _ when next is ImportDeclare => {
        val {org, module, path, name} = next.statement;
        sum.setValue(name, QualifiedType { org, module, path } );
      }
      _ when next is ConstantDeclare => sum.setValue(next.assign.name, lookup.resolveName(next.type, next.pos))
      _ when next is ImplDeclare => {
        if (next.proto != null) {
          next.pos.fail("Protocols are not implemented yet")
        } else {
          if (next.base isNot NamedType) {
            next.pos.fail("Only NamedTypes are supported right now")
          }

          val baseName = next.base.name;
          val qualifiedBase = lookup.getType(baseName)

          if (qualifiedBase isNot QualifiedType) {
            next.pos.fail("Only QualifiedType is expected here")
          }

          val dataScope = lookup.child().setType("this", qualifiedBase)

          next.funcs
            .filter({ dec => includePrivate || dec.access != Private})
            .fold(sum, { innerSum, funDec =>
              val name = "${baseName}.${funDec.func.name}";

              val location = qualified(name);

              val isStatic = funDec.func.body.args.size == 0 || funDec.func.body.args.head() != "this";
              val name = funDec.func.name;
              val type = dataScope.resolveName(funDec.func.body.type, funDec.pos);

              innerSum.setMethod(qualifiedBase, FunctionSignature{ isStatic, name, type }, location)
          });
        }
      }
      _ => sum
    }
   })
}
