import this/Lexer.Position

import this/Ast.AccessModifier
import this/Ast.Public
import this/Ast.Protected
import this/Ast.Internal
import this/Ast.Private

import this/Ast.NullLiteralExp
import this/Ast.BooleanLiteralExp
import this/Ast.NumberLiteralExp
import this/Ast.StringLiteralExp
import this/Ast.ListLiteralExp
import this/Ast.CharLiteralExp
import this/Ast.IdentifierExp
import this/Ast.BinaryOpExp
import this/Ast.UnaryOpExp
import this/Ast.BlockExp
import this/Ast.CallExp
import this/Ast.LambdaExp
import this/Ast.IfExp
import this/Ast.ReturnExp
import this/Ast.ThrowExp
import this/Ast.ConstructExp
import this/Ast.ConstructTupleExp
import this/Ast.MatchExp
import this/Ast.Expression
import this/Ast.Statement
import this/Ast.ExpressionStatement
import this/Ast.AssignmentStatement
import this/Ast.FunctionStatement
import this/Ast.TypeStatement
import this/Ast.ImportStatement
import this/Ast.DeconstructDataStatement
import this/Ast.DeconstructTupleStatement
import this/Ast.DebuggerStatement
import this/Ast.Declaration
import this/Ast.AtomDeclare
import this/Ast.DataDeclare
import this/Ast.TypeDeclare
import this/Ast.FunctionDeclare
import this/Ast.ImportDeclare
import this/Ast.ConstantDeclare
import this/Ast.ProtocolDeclare
import this/Ast.ImplDeclare
import this/Ast.MatchPattern
import this/Ast.AstModule
import this/Ast.AstFile

import this/Type.PrimitiveType
import this/Type.AtomType
import this/Type.DataType
import this/Type.MetaType
import this/Type.ProtocolType
import this/Type.FunctionType
import this/Type.TupleType
import this/Type.GenericType
import this/Type.UnknownType
import this/Type.NamedType
import this/Type.QualifiedName
import this/Type.PlaceholderType
import this/Type.UnionType
import this/Type.IntersectionType
import this/Type.CharType
import this/Type.StringType
import this/Type.IntType
import this/Type.FloatType
import this/Type.BooleanType
import this/Type.AnyType
import this/Type.NullType
import this/Type.UnitType
import this/Type.NothingType
import this/Type.ListType
import this/Type.MapType
import this/Type.VarArgsType
import this/Type.Type

import this/CoreLib.initCoreScope

fun checkModule(module: AstModule): (Set[QualifiedName], List[Map[String, QualifiedName]]) = {
  val core = initCoreScope();

  val allNonPrivateDeclaredTypes: Set[QualifiedName] = module.files.entries().flatMap({ entry =>
    val (path, astFile) = entry;

    collectedExportedTypes(path, astFile)
  }).toSet();

  val allFilesWithScopes: List[Map[String, QualifiedName]] = module.files.entries().map({ entry =>
    val (path, astFile) = entry;

    // make sure all imported types are valid
    verifyImports(allNonPrivateDeclaredTypes, astFile);

    val localTypes = collectAllLocalTypes(path, astFile);

    return (localTypes, astFile);
  });

  return (allNonPrivateDeclaredTypes, allFilesWithScopes);
}

private data TypeDictionary = {
  globals: Set[QualifiedName],

}

private data TypeToken = {
  type: Type,
  scope: TypeScope
}

implement TypeToken {
  fun access(this, base: TypeToken, name: String, pos: Position): TypeToken = {
    match (base) {
      _ when base is AtomType => pos.fail("${base.name} is an Atom and has no fields nor methods")
      _ when base is DataType => {
        // check for fields first, then methods
        val maybeField = base.fields.get(name);

        if (maybeField != null) {
          return TypeToken{ type: maybeField, scope: this };
        }

        // now check for methods
        val maybeMethodToken = this.scope.lookupMethod(base.qualified, name);

        if (maybeMethodToken != null) {
          return maybeMethodToken;
        }

        pos.fail("No field or method with name ${name} on type ${base.qualified.pretty()}");
      }
      _ when base is ProtocolType => pos.fail("Protocols are not supported yet")
      _ when base is FunctionType => pos.fail("Functions don't have properties")
      _ when base is TupleType => pos.fail("Properties on tuples are not yet supported. Destructure to access a tuple's fields")
      _ when base is GenericType => pos.fail("GenericType should not be accessible here")
      _ when base is UnionType => {


      }
    }
  }
}

private data TypeScope = {
  parent: TypeScope,
  values: Map[String, TypeToken],
  methods: Map[QualifiedName, Map[String, TypeToken]],
}

implement TypeScope {
  fun new(): TypeScope = TypeScope{
    parent: null,
    values: Map.of(),
    methods: Map.of()
  }

  fun child(this): TypeScope = {
    val base = new();
    return base{ parent: this };
  }

  fun lookupValue(this, name: String, pos: Position): TypeToken = {
    val maybeLocal = this.values.get(name);

    if (maybeLocal != null) {
      return maybeLocal;
    } else {
      if (this.parent != null) {
        return this.parent.lookupValue(name, pos);
      } else {
        pos.fail("Could not find value $name")
      }
    }
  }

  fun addValue(this, name: String, type: Type): TypeScope = {
    return this{
      values: this.values.set(name, TypeToken{type, scope: this})
    }
  }

  fun lookupMethod(this, qualified: QualifiedName, methodName: String): TypeToken = {
    val maybeMethods = this.methods.get(qualified);

    if (maybeMethods == null) {
      return null;
    }

    return maybeMethods.get(methodName);
  }
}



// just collect all types from this file that the file itself can use to replace all NamedTypes with QualifiedNames
private fun collectAllLocalTypes(basePath: List[String], astFile: AstFile): Map[String, QualifiedName] = {
  fun qualified(name: String): QualifiedName = {
    return QualifiedName { org: 'this', module: 'this', path: basePath.add(name) };
  }

  return astFile.declarations.fold(Map.of(), { dict, dec =>
      match (dec) {
        _ when dec is ImportDeclare => {
          val {org, module, path, name} = dec.statement;

          val initChar = name.getCharAt(0);

          // if name starts with a capital letter, then it's a type. Otherwise it's not and we don't care for it right now
          if (initChar.toUpperCase() == initChar) {
            dict.set(name, QualifiedName{ org, module, path })
          } else {
            dict
          }
        }
        _ when dec is AtomDeclare => dict.set(dec.name, qualified(dec.name))
        _ when dec is DataDeclare => dict.set(dec.name, qualified(dec.name))
        _ when dec is TypeDeclare => dict.set(dec.type.name, qualified(dec.type.name))
        _ when dec is ProtocolDeclare => dec.pos.fail("Protocols are not yet supported")
        _ => dict
      }
    });
}

// collect only the exported types of a file. No private types and no imports
private fun collectedExportedTypes(basePath: List[String], astFile: AstFile): Set[QualifiedName] = {
  fun qualified(name: String): QualifiedName = {
    return QualifiedName { org: 'this', module: 'this', path: basePath.add(name) };
  }

  return astFile.declarations.fold(Set.of(), { dict, dec =>
      if (dec.access == Private) {
        return dict;
      }

      match (dec) {
        _ when dec is AtomDeclare => dict.add(qualified(dec.name))
        _ when dec is DataDeclare => dict.add(qualified(dec.name))
        _ when dec is TypeDeclare => dict.add(qualified(dec.type.name))
        _ when dec is ProtocolDeclare => dec.pos.fail("Protocols are not yet supported")
        _ => dict
      }
    });
}

// make sure that all explicit imports in the file refer to real things that are exported somewhere else
private fun verifyImports(allTypes: Set[QualifiedName], astFile: AstFile): Unit = {
  astFile.declarations.forEach({dec =>
    if (dec is ImportDeclare) {
      val {org, module, path, name} = dec.statement;

      val initChar = name.getCharAt(0);

      // if name starts with a capital letter, then it's a type. Otherwise it's not and we don't care for it right now
      if (initChar.toUpperCase() == initChar) {
        val qualified = QualifiedName{ org, module, path };

        if (!allTypes.contains(qualified)) {
          dec.pos.fail("No such type found to import");
        }
      }
    }
  })
}

private fun qualifyAllTypes(types: Map[String, QualifiedName], astFile: AstFile): AstFile = {
  val declarations = ast.declarations.map({ dec =>
    match (dec) {
      _ when dec is DataDeclare => {
        val body = body.entries().fold(Map.of(), { res, next =>
          val (key, bareType) = next;

          val filledType = qualifyAllTypesType(types, bareType, dec.pos);

          res.set(key, filledType);
        });

        dec{body}
      }
      _ when dec is TypeDeclare => {
        dec{ type: dec.type{ value: qualifyAllTypesType(types, dec.type.value, dec.pos) } }
      }
      _ when dec is FunctionDeclare => {
        qualifyAllTypesFunctionDeclare(types, dec)
      }
      _ when dec is ConstantDeclare => {
        dec{type: qualifyAllTypesType(types, dec.type, dec.pos)}
      }
      _ when dec is ProtocolDeclare => dec.pos.fail("Protocols are not yet supported")
      _ when dec is ImplDeclare => {
        dec{funcs: dec.funcs.map({ func => qualifyAllTypesFunctionDeclare(types, func) })}
      }
      // atom and import have nothing to do
      _ => dec
    }
  });

  return AstFile{ declarations };
}

private fun qualifyAllTypesStatement(types: Map[String, QualifiedName], state: Statement): Statement {
  match(state) {
    _ when state is ExpressionStatement => state{ex: qualifyAllTypesExpression(types, state.ex)}
    _ when state is AssignmentStatement => {
      state {
        declaredType: qualifyAllTypesType(types, state.declaredType, dec.pos),
        body: qualifyAllTypesExpression(types, state.body)
      }
    }
    _ when state is FunctionStatement => qualifyAllTypesFunctionStatement(types, state)
    _ when state is TypeStatement => state{value: qualifyAllTypesType(types, state.value, dec.pos)}
    _ when state is DeconstructDataStatement => {
      state{base: qualifyAllTypesExpression(types, state.base}
    }
    _ when state is DeconstructTupleStatement => {
      state{base: qualifyAllTypesExpression(types, state.base}
    }
    _ => state
  }
}

private fun qualifyAllTypesFunctionDeclare(types: Map[String, QualifiedName], dec: FunctionDeclare): FunctionDeclare {
  return dec{func: qualifyAllTypesFunctionStatement(types, dec.func)}
}

private fun qualifyAllTypesFunctionStatement(types: Map[String, QualifiedName], state: FunctionStatement): FunctionStatement {
  return state{body: qualifyAllTypesLambdaExp(types, state.body)}
}

private fun qualifyAllTypesLambdaExp(types: Map[String, QualifiedName], ex: LambdaExp): LambdaExp {
  return ex {
    type: qualifyAllTypesFunctionType(types, ex.type, ex.pos),
    body: qualifyAllTypesExpression(types, ex.body),
  }
}

private fun qualifyAllTypesExpression(types: Map[String, QualifiedName], ex: Expression): Expression {
  match (ex) {
    _ when ex is ListLiteralExp => ex{args: ex.args.map({e => qualifyAllTypesExpression(types, e)})}
    _ when ex is BinaryOpExp => ex{
      left: qualifyAllTypesExpression(types, ex.left),
      right: qualifyAllTypesExpression(types, ex.right)
    }
    _ when ex is UnaryOpExp => ex{ex: qualifyAllTypesExpression(types, ex.ex)}
    _ when ex is BlockExp => ex{body: ex.body.map({state => qualifyAllTypesStatement(types, state)})}
    _ when ex is CallExp => ex {
      func: qualifyAllTypesExpression(types, ex.func),
      arguments: ex.arguments.map({arg => qualifyAllTypesExpression(types, arg)})
    }
    _ when ex is LambdaExp => qualifyAllTypesLambdaExp(types, ex)
    _ when ex is IfExp => ex {
      condition: qualifyAllTypesExpression(types, ex.condition)
      thenExp: qualifyAllTypesExpression(types, ex.thenExp)
      elseExp: if (ex.elseExp == null) null else qualifyAllTypesExpression(types, ex.elseExp)
    }
    _ when ex is ReturnExp => ex {
      ex: qualifyAllTypesExpression(types, ex.ex)
    }
    _ when ex is ThrowExp => ex {
      ex: qualifyAllTypesExpression(types, ex.ex)
    }
    _ when ex is ConstructExp => ex {
      base: qualifyAllTypesExpression(types, ex.base),
      values: ex.values.map({ pair =>
        val (key, expr) = pair;

        (key, qualifyAllTypesExpression(types, expr))
      })
    }
    _ when ex is ConstructTupleExp => ex {
      values: ex.values.map({ expr => qualifyAllTypesExpression(types, expr) })
    }
    _ when ex is MatchExp => ex {
      base: qualifyAllTypesExpression(types, ex.base),
      patterns: ex.patterns.map({pattern =>
        val {base, guard, body} = pattern;

        pattern {
          base: qualifyAllTypesExpression(types, base),
          guard: qualifyAllTypesExpression(types, guard),
          body: qualifyAllTypesExpression(types, body),
        }
      })
    }
  }
}

private fun qualifyAllTypesType(types: Map[String, QualifiedName], type: Type, pos: Position): Type {
  match (type) {
    _ when type is DataType => type{fields: type.fields.map({pair =>
      val (key, value) = pair;

      (key, qualifyAllTypesType(types, value, pos))
    })}
    _ when type is FunctionType => qualifyAllTypesFunctionType(types, type, pos)
    _ when type is VarArgsType => type{base: qualifyAllTypesType(types, type.base, pos)}
    _ when type is TupleType => type{paramTypes: }
  }
}

private fun qualifyAllTypesFunctionType(types: Map[String, QualifiedName], type: FunctionType, pos: Position): FunctionType {

}

