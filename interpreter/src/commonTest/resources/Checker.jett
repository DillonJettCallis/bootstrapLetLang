import self/Lexer.Position

import self/Ast.AccessModifier
import self/Ast.Public
import self/Ast.Protected
import self/Ast.Internal
import self/Ast.Private

import self/Ast.NullLiteralExp
import self/Ast.BooleanLiteralExp
import self/Ast.NumberLiteralExp
import self/Ast.StringLiteralExp
import self/Ast.ListLiteralExp
import self/Ast.CharLiteralExp
import self/Ast.IdentifierExp
import self/Ast.BinaryOpExp
import self/Ast.UnaryOpExp
import self/Ast.BlockExp
import self/Ast.CallExp
import self/Ast.LambdaExp
import self/Ast.IfExp
import self/Ast.ReturnExp
import self/Ast.ThrowExp
import self/Ast.ConstructExp
import self/Ast.ConstructTupleExp
import self/Ast.MatchExp
import self/Ast.Expression
import self/Ast.Statement
import self/Ast.ExpressionStatement
import self/Ast.AssignmentStatement
import self/Ast.FunctionStatement
import self/Ast.TypeStatement
import self/Ast.ImportStatement
import self/Ast.DeconstructDataStatement
import self/Ast.DeconstructTupleStatement
import self/Ast.DebuggerStatement
import self/Ast.Declaration
import self/Ast.AtomDeclare
import self/Ast.DataDeclare
import self/Ast.TypeDeclare
import self/Ast.FunctionDeclare
import self/Ast.ImportDeclare
import self/Ast.ConstantDeclare
import self/Ast.ProtocolDeclare
import self/Ast.ImplDeclare
import self/Ast.MatchPattern
import self/Ast.AstModule
import self/Ast.AstPackage

import self/Type.PrimitiveType
import self/Type.AtomType
import self/Type.DataType
import self/Type.ProtocolType
import self/Type.FunctionType
import self/Type.TupleType
import self/Type.GenericType
import self/Type.UnknownType
import self/Type.NamedType
import self/Type.PlaceholderType
import self/Type.UnionType
import self/Type.IntersectionType
import self/Type.CharType
import self/Type.StringType
import self/Type.IntType
import self/Type.FloatType
import self/Type.BooleanType
import self/Type.AnyType
import self/Type.NullType
import self/Type.UnitType
import self/Type.NothingType
import self/Type.ListType
import self/Type.MapType
import self/Type.Type

data TypeRegistry = { types: Map[Int, Type], extensions: Map[Int, List[Int]], impls: Map[Int, List[Int]] }

fun TypeRegistry.resolve(self, id: Int): Option[Type] = self.types.get(id)
fun TypeRegistry.registerType(self, type: Type): Self = self{types: self.types.set( self.types.size(), type )}
fun TypeRegistry.registerExtension(self, baseId: Int, func: Type)


data PackageScope = { env: Map[String, PackageScope], values: Map[List[String], (AccessModifier, Type)] }


fun PackageScope.lookupImport(self, ex: ImportStatement, currentPath: List[String]): Type = {
  val { packageName, modulePath, pos} = ex;

  if (packageName == 'self') {
    val item = self.values.get(modulePath);

    if (item == null) {
      pos.fail("${ item.join('.') } does not exist")
    }

    val (itemAccess, itemType) = item

    val isAccessible = match (itemAccess) {
      Public => true
      Internal => true
      Private => false
      Protected => currentPath.size() >= modulePath.size() && modulePath.zip(currentPath).all({ left, right => left == right })
    }

    if (isAccessible) {
      return itemType;
    } else {
      pos.fail("${ item.join('.') } is not accessible here")
    }
  } else {
    val package = self.env.get(packageName)

    if (package == null) {
      pos.fail("No such package '$packageName' found")
    }

    val item = package.values.get(modulePath)

    if (item == null) {
      pos.fail("${ item.join('.') } is not a valid public member of $packageName")
    }

    val (itemAccess, itemType) = item

    if (itemAccess == Public) {
      return itemType
    } else {
      pos.fail("${ item.join('.') } is not a valid public member of $packageName")
    }
  }
}

fun PackageScope.insertDeclaration(self, modulePath: List[String], access: AccessModifier, type: Type): PackageScope = {
  self{values: self.values.set(modulePath, (access, type))}
}

data Scope = { values: Map[String, Type], parent: Scope }

fun Scope.get(self, name: String, pos: Position): Type = {
  if (self.values.contains(name)) {
    return self.values.get(name)
  } else {
    if (self.parent != null) {
      return self.parent.get(name, pos)
    } else {
      pos.fail("Unknown type $name is not in scope")
    }
  }
}

fun Scope.set(self, name: String, type: Type): Scope = self{values: values.set(name, type)}

fun Scope.child(self): Scope = Scope { values: Map.of(), parent: self }


fun Scope.init(): Scope = Scope { values: Map.of(), parent: null }


fun checkPackage(pack: AstPackage, env: Map[String, PackageScope]): AstPackage = {
  val packageScope = PackageScope { env, values: Map.of() }

  val namesOnly = packageScope.entries.fold(packageScope, { pack, pair =>
    val (modulePath, module) = pair

    populateNames(modulePath, module, pack)
  });


}

private fun populateNames(moduleBase: List[String], module: AstModule, initPackage: PackageScope): PackageScope = {
  module.declarations.fold(initPackage, { pack, dec =>
    match (dec) {
      _ when dec is AtomDeclare => pack.insertDeclaration( moduleBase.add(dec.name), dec.access, AtomType{name: dec.name} )
      _ when dec is DataDeclare => pack.insertDeclaration ( moduleBase.add(dec.name), dec.access, DataType { name: dec.name, fields: dec.body, typeParams: List.of() } )
      _ when dec is TypeDeclare => pack.insertDeclaration ( moduleBase.add(dec.type.name), dec.access, dec.type.value )
      _ when dec is FunctionDeclare => pack.insertDeclaration ( moduleBase.add(dec.func.name), dec.access, dec.func.body.type )
      _ when dec is ImportDeclare => pack
      _ when dec is ConstantDeclare => pack.insertDeclaration ( moduleBase.add(dec.assign.name), dec.access, dec.assign.body.type )
      _ when dec is ProtocolDeclare => dec.pos.fail("Protocols are not yet supported")
      _ when dec is ImplDeclare => {
        val baseName = if ( dec.base is NamedType ) dec.name else dec.pos.fail("Something is very wrong. Type checker expects the parser to always produce NamedType for the base of an ImplDeclare")

        if ( dec.proto != null ) {
          dec.pos.fail("Protocols are not yet supported")
        }

        dec.funcs.fold(pack) { pack, func =>
          val funcName = "$baseName.${func.func.name}"

          pack.insertDeclaration( moduleBase.add(funcName), func.access, func.func.body.type )
        }
      }
    }
  })
}

private fun verifyImports(moduleBase: List[String], module: AstModule, initPackage: PackageScope): Scope = {
  module.declarations.fold(initScope(), { scope, dec =>
    if (dec is ImportDeclare) {
      val state = dec.import;
      scope.set(state.modulePath.last(), initPackage.lookupImport(state, moduleBase))
    } else {
      scope
    }
  };
}
