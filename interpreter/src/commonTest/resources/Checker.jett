import this/Lexer.Position

import this/Ast.AccessModifier
import this/Ast.Public
import this/Ast.Protected
import this/Ast.Internal
import this/Ast.Private

import this/Ast.AssignmentStatement
import this/Ast.AstFile
import this/Ast.AstModule
import this/Ast.AtomDeclare
import this/Ast.BinaryOpExp
import this/Ast.BlockExp
import this/Ast.BooleanLiteralExp
import this/Ast.CallExp
import this/Ast.CharLiteralExp
import this/Ast.ConstantDeclare
import this/Ast.ConstructExp
import this/Ast.ConstructTupleExp
import this/Ast.DataDeclare
import this/Ast.DebuggerStatement
import this/Ast.Declaration
import this/Ast.DeconstructDataStatement
import this/Ast.DeconstructTupleStatement
import this/Ast.Expression
import this/Ast.ExpressionStatement
import this/Ast.FieldAccessExp
import this/Ast.FunctionDeclare
import this/Ast.FunctionStatement
import this/Ast.IdentifierExp
import this/Ast.IfExp
import this/Ast.ImplDeclare
import this/Ast.ImportDeclare
import this/Ast.ImportStatement
import this/Ast.LambdaExp
import this/Ast.LiteralExpression
import this/Ast.MatchExp
import this/Ast.MatchPattern
import this/Ast.NullLiteralExp
import this/Ast.NumberLiteralExp
import this/Ast.ProtocolDeclare
import this/Ast.ReturnExp
import this/Ast.Statement
import this/Ast.StringLiteralExp
import this/Ast.ThrowExp
import this/Ast.TypeDeclare
import this/Ast.TypeStatement
import this/Ast.UnaryOpExp

import this/Type.AnyType
import this/Type.AtomType
import this/Type.BooleanType
import this/Type.CharType
import this/Type.DataType
import this/Type.FloatType
import this/Type.FunctionType
import this/Type.GenericType
import this/Type.IntType
import this/Type.IntersectionType
import this/Type.MetaType
import this/Type.NamedType
import this/Type.NothingType
import this/Type.NullType
import this/Type.PlaceholderType
import this/Type.PrimitiveType
import this/Type.ProtocolType
import this/Type.QualifiedType
import this/Type.StringType
import this/Type.TupleType
import this/Type.Type
import this/Type.UnionType
import this/Type.UnitType
import this/Type.UnknownType
import this/Type.VarArgsType

import this/CoreLib.initCoreScope

import this/Sweeper.Scope

fun checkModule(allFilesWithScopes: List[(Scope, AstFile)]): List[(AstFile, List[(QualifiedType, Declaration)] )] = {
  val core = initCoreScope();

  val moduleTypeDefs = allFilesWithScopes.fold(Map.of(), { defs, pair =>
    val (fileScope) = pair;

    defs.concat(fileScope.parent.typeDefs)
  });

  // bring all the type defs together into a single module scope
  val coreChild = core.child();
  val moduleScope = coreChild{typeDefs: moduleTypeDefs };

  val checkedFiles = allFilesWithScopes.map({ pair =>
    val (fileScope, astFile) = pair;

    // rewire the fileScope's parent to point through moduleScope

    val publicScope = fileScope.parent { parent: moduleScope };
    val privateScope = fileScope{ parent: publicScope };

    (astFile, checkDeclarations(privateScope, astFile))
  })

  return checkedFiles
}

private fun checkDeclarations(fileScope: Scope, file: AstFile): List[(QualifiedType, Declaration)] = {
  fun qualified(name: String): QualifiedType = {
    return QualifiedType { org: 'this', module: 'this', path: file.path.add(name) };
  }

  file.declarations.map({ dec =>
    match (dec) {
      _ when dec is AtomDeclare => (qualified(dec.name), dec)
      _ when dec is DataDeclare => {
        val qualifiedName = qualified(dec.name);

        val body = dec.body.entries().map({ pair =>
          val (key, rawType) = pair;
          val resolvedType = fileScope.fullyQualify(rawType, dec.pos);

          // verify that the resolved type exists
          fileScope.verifyType(resolvedType, dec.pos);

          (key, resolvedType)
        });

        val result = dec{body};

        (qualifiedName, result)
      }
      _ when dec is TypeDeclare => {
        val name = qualified(dec.type.name);
        // add 'This' type before qualifying
        val value = fileScope.setType("This", name)
          .fullyQualify(dec.type.value, dec.pos);
        val type = dec.type{value};
        val result = dec{type};

        (name, result)
      }
      _ when dec is ConstantDeclare => {
        val name = qualified(dec.assign.name);
        val declaredType = fileScope.fullyQualify(dec.assign.declaredType, dec.pos);

        val body = checkExpression(fileScope, dec.assign.body);

        if (body.type == UnknownType) {
          dec.pos.fail("Unresolvable type")
        }

        val assign = if (declaredType != UnknownType) {
          val fit = scope.fit(body.type, declaredType, dec.pos);

          match (fit) {
            _ when fit is PerfectFit => dec.assign{ declaredType: declaredType, body }
            _ when fit is ProtocolFit => {
              val finalEx = WrapProtocolExp{ base: body, pos: next.pos, type: fit.impl.proto };

              dec.assign{ declaredType: declaredType, body: finalEx };
            }
          }
        } else {
          return dec.assign{ declaredType: body.type, body };
        };

        dec{assign}
      }
      _ => {
        println("Trying to check unknown declaration");
        dec
      }
    }
  })
}

// this is not just checking a single statement because things like if's can rearrange the statements in a block
private fun checkBlock(blockScope: Scope, block: BlockExp): Expression = {

  // first we check for ifs with no else and turn the remainder of the block body into the else
  fun collapseIfs(body: List[Statement]): List[Statement] = {
    val ifWithoutElseIndex = body.findIndex({ state =>
      if (state is ExpressionStatement) {
        // flow typing can't ensure that state.ex is an IfExp, it only works on single variables, so we declare ex here
        val ex = state.ex

        ex is IfExp && ex.elseExp == null
      } else {
        false
      }
    });

    // if there was no match or if the match was the very last statement return
    if (ifWithoutElseIndex == -1 || ifWithoutElseIndex == body.size - 1) {
      return body;
    }

    val state = body.get(ifWithoutElseIndex)

    if (state isNot ExpressionStatement) {
      state.pos.fail("Impossible, we just checked this")
    }

    val ifEx = state.ex;

    if (ifEx isNot IfExp) {
      ifEx.pos.fail("Doubly impossible, we checked this too")
    }

    val init = body.slice(0, ifWithoutElseIndex)
    val elseExp = body.slice(ifWithoutElseIndex + 1, body.size)

    val result = init.add( ifEx{elseExp} )

    // recurse until there are no matches
    return collapseIfs(result);
  }

  val ifReducedBody = collapseIfs(block.body);

  fun foldBody(scope: Scope, next: Statement): (Scope, Statement) = {
    match(next) {
      _ when next is ExpressionStatement => {
        val ex = checkExpression(scope, next.ex);

        return (scope, next{ex});
     }
     _ when next is AssignmentStatement => {
       val {name, declaredType} = next;
       val resolvedDecType = scope.fullyQualify(declaredType, next.pos);

       val body = checkExpression(scope, next.body)

       if (body.type == UnknownType) {
        next.pos.fail("Unresolvable type")
       }

       if (resolvedDecType != UnknownType) {
        val fit = scope.fit(body.type, resolvedDecType, next.pos);

        match (fit) {
          _ when fit is PerfectFit => return (scope.setValue(name, resolvedDecType), next{ declaredType: resolvedDecType, body } )
          _ when fit is ProtocolFit => {
            val finalEx = WrapProtocolExp{ base: body, pos: next.pos, type: fit.impl.proto };

            return (scope.setValue(name, resolvedDecType), next{ declaredType: resolvedDecType, body: finalEx });
          }
        }
       } else {
        return (scope.setValue(name, body.type), next{ declaredType: body.type, body });
       }
     }
     _ when next is FunctionStatement => {
      val body = checkExpression(scope, next.body);

      return (scope.setValue(next.name, body.type), next{body});
     }
     _ when next is TypeStatement => {
      val type = scope.fullyQualify(next.type, next.pos);

      return (scope.setType(next.name, type), next{type});
     }
     _ when next is ImportStatement => {
      val {org, module, path, name} = next;
      val qualified = QualifiedType{ org, module, path };

      // this will throw if it wasn't found
      scope.getTypeDef(qualified, next.pos);

      val finalScope = scope.setType(name, qualified).setValue(name, qualified)

      return (finalScope, next)
     }
     _ when next is DeconstructDataStatement => {
       val base = checkExpression(scope, next.base);

       val qualifiedBase = scope.fullQualify(base.type, next.pos);
       val def = scope.getTypeDef(qualifiedBase, next.pos)

       if (def isNot DataType) {
        next.pos.fail("Destructure can only be used on tuples and data types")
       }

       val finalScope = next.values.fold(scope, { nextScope, next =>
          val (srcName, destName) = next;

          val (accessType, type) = nextScope.access(qualifiedBase, srcName, next.pos)

          if (accessType != FieldAccess) {
            next.pos.fail("No field named ${srcName} found");
          }

          nextScope.setValue(destName, type)
       });

       return (finalScope, next{base});
     }
     _ when next is DeconstructTupleStatement => {
      val base = checkExpression(scope, next.base);

      val def = scope.getTypeDef(scope.fullQualify(base.type, next.pos), next.pos);

      if (def isNot TupleType) {
        next.pos.fail("Tuple destructor can only be used on tuple")
      }

      if (def.typeParams.size < next.names.size) {
        next.pox.fail("Attempt to destructure more items in tuple than exist")
      }

      val finalScope = next.names.zip(def.typeParams).fold(scope, {nextScope, next =>
        val (name, type) = next;
        nextScope.setValue(name, type)
      });

      return (finalScope, next{base});
     }
     _ when next is DebuggerStatement => (scope, next)
    }
  }

  val (finalScope, body) = ifReducedBody.accumulate(blockScope, foldBody);

  val lastEx = {
    val lastEx = body.last();

    if (lastEx is DebuggerStatement) {
      // weird special case we need to handle - don't put two of these in a row
      body.init().last()
    } else {
      lastEx
    }
  };

  if (lastEx isNot ExpressionStatement)  {
    lastEx.pos.fail("Last statement in a block must be an expression")
  }

  val type = lastEx.ex.type;

  return block{ body, type }
}

private fun checkExpression(scope: Scope, ex: Expression): Expression = {
  match (ex) {
    _ when ex is LiteralExpression => ex // literals always have the correct type
    _ when ex is IdentifierExp => {
      val type = scope.getValue(ex.name);

      ex{type}
    }
    _ when ex is BinaryOpExp => {
      // for now at least we're hard coding our basic ops
      match (ex.op) {
        // these only work on two numbers of the same type
        "+" => checkMathOp(scope, ex)
        "-" => checkMathOp(scope, ex)
        "*" => checkMathOp(scope, ex)
        "/" => checkMathOp(scope, ex)

        // same for these
        ">" => checkMathOp(scope, ex)
        ">=" => checkMathOp(scope, ex)
        "<" => checkMathOp(scope, ex)
        "<=" => checkMathOp(scope, ex)

        // for now these can work on ANY types
        "==" => ex{ left: checkExpression(scope, ex.left), right: checkExpression(scope, ex.right), type: BooleanType }
        "!=" => ex{ left: checkExpression(scope, ex.left), right: checkExpression(scope, ex.right), type: BooleanType }

        // these guys check for a type on the right side, not a value
        "is" => checkIsOp(scope, ex)
        "isNot" => checkIsOp(scope, ex)

        // and these two perform type assertions as they go
        "&&" => checkAndOp(scope, ex)
        "||" => checkOrOp(scope, ex)
        _ => ex.pos.fail("Invalid operator ${ex.op}")
      }
    }
    _ when ex is UnaryOpExp => {
      match (ex.op) {
        "-" => {
          val base = checkExpression(scope, ex.ex);

          val type = match (base.type) {
            FloatType => FloatType
            IntType => IntType
            _ => ex.pos.fail("Unary ''-' can only be applied to floats or ints")
          }

          ex{ex: base, type}
        }
        "!" => {
          val base = checkExpression(scope, ex.ex);

          if (base.type != BooleanType) {
            ex.pos.fail("'!' operator can only be applied to boolean expressions")
          }

          ex{ex: base, type: BooleanType}
        }
      }
    }
    _ when ex is BlockExp => checkBlock(scope.child(), ex)
    _ when ex is FieldAccessExp => checkAccess(scope, ex)
    _ when ex is CallExp => {
      val func = checkExpression(scope, ex.func)
      val funcType = scope.getTypeDef(func.type);

      if (funcType isNot FunctionType) {
        ex.pos.fail("Attempt to call non-function of type $funcType");
      }

      debugger;
      ex
    }
    _ => ex
  }
}

private fun checkMathOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  // must be the same type: ie: both ints or both floats

  val left = checkExpression(scope, base.left);
  val right = checkExpression(scope, base.right);

  if (left.type != right.type) {
    base.pos.fail("Binary expression must be both ints or both floats, instead found left: ${left.type} and right: ${right.type}");
  }

  val type = match (left.type) {
    IntType => { IntType }
    FloatType => { FloatType }
    _ => base.pos.fail("Binary expression must be both ints or both floats, instead found left: ${left.type} and right: ${right.type}")
  }

  return base{left, right, type};
}

private fun checkIsOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  // left side is variable but right is type. Works for both is and isNot

  val left = checkExpression(scope, base.left);
  val rawRight = base.right;

  if (rawRight is IdentifierExp) {
    val rightType = scope.getType(rawRight.name, rawRight.pos);
    val right = rawRight{type: rightType};

    return base{left, right, type: BooleanType};
  } else {
    base.pos.fail("Right side of ${base.op} expression must be a type identifier")
  }
}

private fun checkAndOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  val left = checkExpression(scope, base.left);

  if (left.type != BooleanType) {
    base.pos.fail("Expected boolean expression left of &&");
  }

  val {whenTrue} = flowSensitiveAnalysis(scope, left);

  val right = checkExpression(whenTrue, base.right);

  if (right.type != BooleanType) {
    base.pos.fail("Expected boolean expression right of ||");
  }

  base{ left, right, type: BooleanType }
}

private fun checkOrOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  val left = checkExpression(scope, base.left);

  if (left.type != BooleanType) {
    base.pos.fail("Expected boolean expression left of &&");
  }

  val {whenFalse} = flowSensitiveAnalysis(scope, left);

  val right = checkExpression(whenFalse, base.right);

  if (right.type != BooleanType) {
    base.pos.fail("Expected boolean expression right of ||");
  }


  base{ left, right, type: BooleanType }
}

private fun checkAccess(scope: Scope, access: FieldAccessExp): FieldAccessExp = {
  val base = checkExpression(scope, access.base);

  val name = base.name;

  val (accessType, type) = scope.access(base.type, name, access.pos);

  access{base, type}
}

data FlowScope = { whenTrue: Scope, whenFalse: Scope }

private fun flowSensitiveAnalysis(baseScope: Scope, ex: Expression): FlowScope = {
  // assume ex has been properly typed

  match (ex) {
    _ when ex is BinaryOpExp => {
      match (ex.op) {
        "is" => doIsTypeAssertion(baseScope, ex)
        "isNot" => {
          // literally the same as 'is' just reversed outcomes
          val {whenTrue: whenFalse, whenFalse: whenTrue} = doIsTypeAssertion(baseScope, ex);
          FlowScope{ whenTrue, whenFalse }
        }
        "&&" => {
          val {whenTrue: prevWhenTrue, whenFalse} = flowSensitiveAnalysis(baseScope, ex.left);

          // pass only the true result into the right side, return it's value
          val {whenTrue} = flowSensitiveAnalysis(prevWhenTrue, ex.right)

          FlowScope{ whenFalse, whenTrue }
        }
        "||" => {
          val {whenFalse: prevWhenFalse, whenTrue} = flowSensitiveAnalysis(baseScope, ex.left);

          // the reverse of &&, pass only the false result into the right side, return it's value
          val {whenFalse} = flowSensitiveAnalysis(prevWhenFalse, ex.right)

          FlowScope{ whenTrue, whenFalse }
        }
        _ => FlowScope{ whenTrue: baseScope, whenFalse: baseScope }
      }
    }
    _ => FlowScope{ whenTrue: baseScope, whenFalse: baseScope }
  }
}

private fun doIsTypeAssertion(baseScope: Scope, ex: BinaryOpExp): FlowScope = {
  val left = ex.left;
  val right = ex.right;

  if (left is IdentifierExp && right is IdentifierExp) {
    val rawType = left.type;

    val whenTrue = baseScope.setValue(left.name, right.type);
    val whenFalse = if (rawType is UnionType) {
      // if the left side is a union, we now know that it can't be the right type, so remove that from the union
      val paramTypes = rawType.paramTypes.filter({ it => it != right.type})

      val assertedType = if (paramTypes.size == 1) {
        paramTypes.get(0)
      } else {
        UnionType{paramTypes}
      }

      baseScope.setValue(left.name, assertedType)
    } else {
      baseScope
    }

    FlowScope{ whenTrue, whenFalse }
  } else {
    FlowScope{ whenTrue: baseScope, whenFalse: baseScope }
  }
}

private fun resolveFunction(scope: Scope, func: FunctionType, arguments: List[Expression]): (FunctionType, List[Expression]) = {
  val typedArgs = arguments.map({ next => checkExpression(scope, next) });

  val fullFunc = if (func.typeParams.isEmpty()) {
    func
  } else {

  }
}

private fun resolveGenerics(typeScope: Map[String, Type], genType: Type, fullType: Type, pos: Position): Map[String, Type] = {
  match (genType) {
    _ when genType is PlaceholderType => {
      val name = genType.name;

      if (typeScope.contains(name)) {
        val existing = typeScope.get(name)

        fit()
      }
    }
    _ when genType is GenericType => {
      if (fullType is GenericType) {
        if (genType.typeParams.size == fullType.typeParams.size) {
          val (scopeWithBase, base) = resolveGenerics(typeScope, genType.base, fullType.base, pos);

          genType.typeParams.zip(fullType.typeParams).fold(scopeWithBase, { scope, next =>
            val (gen, full) = next;

            resolveGenerics(scope, gen, full, pos)
          });
        } else {
          pos.fail("Generic types of function and arguments don't match");
        }
      } else {
        pos.fail("Arguments don't match function")
      }
    }
    _ when genType is TupleType => {
      if (fullType is TupleType) {
        if (genType.typeParams.size == fullType.typeParams.size) {
          genType.typeParams.zip(fullType.typeParams).fold(typeScope, { scope, next =>
            val (gen, full) = next;

            resolveGenerics(scope, gen, full, pos)
          });
        } else {
          pos.fail("Function and arguments both have tuple but arity doesn't match");
        }
      } else {
        pos.fail("Arguments don't match function")
      }
    }

  }
}
