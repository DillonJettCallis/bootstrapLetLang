import this/Lexer.Position

import this/Ast.AccessModifier
import this/Ast.Public
import this/Ast.Protected
import this/Ast.Internal
import this/Ast.Private

import this/Ast.NullLiteralExp
import this/Ast.BooleanLiteralExp
import this/Ast.NumberLiteralExp
import this/Ast.StringLiteralExp
import this/Ast.ListLiteralExp
import this/Ast.CharLiteralExp
import this/Ast.IdentifierExp
import this/Ast.BinaryOpExp
import this/Ast.UnaryOpExp
import this/Ast.BlockExp
import this/Ast.CallExp
import this/Ast.LambdaExp
import this/Ast.IfExp
import this/Ast.ReturnExp
import this/Ast.ThrowExp
import this/Ast.ConstructExp
import this/Ast.ConstructTupleExp
import this/Ast.MatchExp
import this/Ast.Expression
import this/Ast.Statement
import this/Ast.ExpressionStatement
import this/Ast.AssignmentStatement
import this/Ast.FunctionStatement
import this/Ast.TypeStatement
import this/Ast.ImportStatement
import this/Ast.DeconstructDataStatement
import this/Ast.DeconstructTupleStatement
import this/Ast.DebuggerStatement
import this/Ast.Declaration
import this/Ast.AtomDeclare
import this/Ast.DataDeclare
import this/Ast.TypeDeclare
import this/Ast.FunctionDeclare
import this/Ast.ImportDeclare
import this/Ast.ConstantDeclare
import this/Ast.ProtocolDeclare
import this/Ast.ImplDeclare
import this/Ast.MatchPattern
import this/Ast.AstModule
import this/Ast.AstFile

import this/Type.PrimitiveType
import this/Type.AtomType
import this/Type.DataType
import this/Type.MetaType
import this/Type.ProtocolType
import this/Type.FunctionType
import this/Type.TupleType
import this/Type.GenericType
import this/Type.UnknownType
import this/Type.NamedType
import this/Type.QualifiedType
import this/Type.PlaceholderType
import this/Type.UnionType
import this/Type.IntersectionType
import this/Type.CharType
import this/Type.StringType
import this/Type.IntType
import this/Type.FloatType
import this/Type.BooleanType
import this/Type.AnyType
import this/Type.NullType
import this/Type.UnitType
import this/Type.NothingType
import this/Type.ListType
import this/Type.MapType
import this/Type.VarArgsType
import this/Type.Type

import this/CoreLib.initCoreScope

private data DependencyScope = {
  values: Map[String, Type]
}

private data ModuleScope = {
  deps: Map[(String, String), DependencyScope],
  files: Map[String, (AstFile, Scope)]
}

data FunctionSignature = {
  isStatic: Boolean,  // is this a static function?
  name: String        // the name of this method
}

data MethodMap = {
  // map the method signature to the full location of the method.
  // This DOES include protocol implementations for this type
  // Protocol impls are merged into here AND go into their own protocol map
  methods: Map[FunctionSignature, QualifiedType]
}

data ProtocolImplPair = {
  // A pair of the protocol and the implementation type. Used as a key in maps
  proto: QualifiedType,
  base: QualifiedType
}

atom FieldAccess    // this is getting a field off a datatype
atom StaticAccess   // this is calling a static method on either a datatype or a protocol
atom MethodAccess   // this is calling staticly known instance method, could be on an impl but also from a proto with a known impl.
atom ProtocolAccess // calling a protocol implementation, so it is dynamic based on the runtime type of the receiver
atom DynamicAccess  // this is with ether a union or intersection type, the impl is based on the runtime type of the receiver

type AccessType = FieldAccess | MethodAccess | ProtocolAccess

atom PerfectFit                               // this type fits into the target type with no special handling
data ProtocolFit = { impl: ProtocolImplPair } // this type needs a protocol impl to fit into this target type

type FitType = PerfectFit | ProtocolFit

data Scope = {
  parent: Scope,
  // maps a fully qualified type to it's actual type which itself can NOT be a QualifiedType but a type that holds QualifiedTypes.
  typeDefs: Map[QualifiedType, Type],
  types: Map[String, QualifiedType],
  values: Map[String, QualifiedType],
  methods: Map[QualifiedType, MethodMap],
  protocolImpls: Map[ProtocolImplPair, MethodMap]
}

implement Scope {

  fun new(): Scope = Scope {
    parent: null,
    typeDefs: Map.of(),
    types: Map.of(),
    values: Map.of(),
    methods: Map.of(),
    protocolImpls: Map.of()
  }

  fun child(this): Scope = {
    val base = Scope.new();
    base { parent: this }
  }

  fun setTypeDef(this, name: QualifiedType, value: Type): Scope = this{ typeDefs: this.typeDefs.set(name, value) }
  fun getTypeDef(this, name: QualifiedType, pos: Position): Type = {
    val mine = this.typeDefs.get(name);

    if (mine == null) {
      if (this.parent == null) {
        pos.fail("Unknown type $name")
      } else {
        return this.parent.getTypeDef(name, pos)
      }
    } else {
      return mine
    }
  }

  fun setType(this, name: String, value: QualifiedType): Scope = this{ types: this.types.set(name, value) }
  fun getType(this, name: String): Type = {
    val mine = this.types.get(name);

    if (mine == null) {
      if (this.parent == null) {
        return null
      } else {
        return this.parent.getType(name)
      }
    } else {
      return mine
    }
  }

  fun setValue(this, name: String, value: QualifiedType): Scope = this{ values: this.values.set(name, value) }
  fun getValue(this, name: String, pos: Position): QualifiedType = {
    val mine = this.values.get(name);

    if (mine == null) {
      if (this.parent == null) {
        return pos.fail("Use of undeclared value $name")
      } else {
        return this.parent.getValue(name)
      }
    } else {
      return mine
    }
  }

  fun fullyQualify(this, init: Type, pos: Position): QualifiedType = {
    match (init) {
      _ when init is QualifiedType => init
      _ when init is NamedType => {
        val result = this.getType(init.name);

        if (result == null) {
          pos.fail("No such type with name ${init.name} in scope");
        } else {
          return result;
        }
      }
      _ when init is AtomType => init
      _ when init is DataType => {
        // inside the fields of a data type you can use "This" to refer to yourself.
        val dataScope = this.setType(init.name, init)
          .setType("This", init);

        val withPlaceholders = init
          .typeParams
          .fold(dataScope, {scope, placeholder => scope.setType(placeholder.name, placeholder)});

        val fields = init.fields.entries().map({pair =>
          val (name, field) = pair;
          (name, withPlaceholders.fullyQualify(field, pos))
        });

        init{fields}
      }
      _ when init is ProtocolType => {
        val dataScope = this.setType(init.name, init)
                  .setType("This", init);
        val withPlaceholders = init
          .typeParams
          .fold(dataScope, {scope, placeholder => scope.setType(placeholder.name, placeholder)});

        val functions = init.functions.entries().map({pair =>
          val (name, field) = pair;
          (name, withPlaceholders.fullyQualify(field, pos))
        });

        init{functions}
      }
      _ when init is FunctionType => {
        val withPlaceholders = init
          .typeParams
          .fold(this, {scope, placeholder => scope.setType(placeholder.name, placeholder)});

        val resultType = withPlaceholders.fullyQualify(init.resultType, pos);
        val paramTypes = init.paramTypes.map({ type => withPlaceholders.fullyQualify(type, pos) });

        init{resultType, paramTypes}
      }
      _ when init is VarArgsType => VarArgsType{base: this.fullyQualify(init.base, pos)}
      _ when init is GenericType => GenericType{ base: this.fullyQualify(init.base), paramTypes: init.paramTypes.map({type => this.fullyQualify(type)}) }
      _ when init is TupleType => TupleType{ paramTypes: init.paramTypes.map({type => this.fullyQualify(type)}) }
      _ when init is UnionType => UnionType{ paramTypes: init.paramTypes.map({type => this.fullyQualify(type)}) }
      _ when init is IntersectionType => IntersectionType{ paramTypes: init.paramTypes.map({type => this.fullyQualify(type)}) }
      _ when init is PrimitiveType => init
      _ => pos.fail("Unknown type")
    }
  }

  fun setMethod(this, base: QualifiedType, sig: FunctionSignature, impl: QualifiedType): Scope = {
    val existingMap = this.methods.get(base)

    val methods = {
      if (existingMap == null) {
        Map.of()
      } else {
        existingMap.methods
      }
    }.set(sig, impl);

    val methods = this.methods.set(base, MethodMap{ methods });

    return this{methods};
  }

  private fun findMethods(this, base: QualifiedType): MethodMap = {
    val map = this.methods.get(base);

    if (map == null) {
      if (this.parent == null) {
        return null;
      } else {
        return this.parent.findMethods(base);
      }
    } else {
      return map;
    }
  }

  fun setProtoImpl(this, key: ProtocolImplPair, impl: MethodMap): Scope = this{ protocolImpls: this.protocolImpls.set(key, impl)}
  private fun findProtoImpl(this, key: ProtocolImplPair): MethodMap = {
    val maybe = this.protocolImpls.get(key);

    if (maybe == null) {
      if (parent == null) {
        return null;
      } else {
        return parent.findProtoImpl(key);
      }
    } else {
      return maybe;
    }
  }

  fun access(this, rawBase: QualifiedType, name: String, pos: Position): (AccessType, QualifiedType) = {
    val base = this.getTypeDef(rawBase, pos);

    match (base) {
      _ when base is AtomType => {
        // no fields or instance methods on an atom so let's check for static methods
        val sig = FunctionSignature{ isStatic: true, name };

        val methodMap = this.findMethods(rawBase);

        if (methodMap != null) {
          val method = methodMap.methods.get(sig);

          if (method != null) {
            return (StaticAccess, method);
          }
        } else {
          pos.fail("No such method ${name} found on atom ${base.name}");
        }
      }
      _ when base is DataType => {
        // check fields first

        val field = base.fields.get(name);

        if (field != null) {
          if (field isNot QualifiedType) {
            pos.fail("Something is wrong. DataType fields should be all qualified types at this point")
          }

          return (FieldAccess, field);
        }

        // not a field, check instance methods
        val sig = FunctionSignature{ isStatic: false, name };

         val methodMap = this.findMethods(rawBase);

         if (methodMap != null) {
          val method = methodMap.methods.get(sig);

          if (method != null) {
            return (MethodAccess, method);
          }
         } else {
           pos.fail("No such method ${name} found on data type ${base.name}");
         }
      }
      _ when base is ProtocolType => {
        // check protocol methods
        val sig = FunctionSignature{ isStatic: false, name };

         val methodMap = this.findMethods(rawBase);

         if (methodMap != null) {
          val method = methodMap.methods.get(sig);

          if (method != null) {
            return (ProtocolAccess, method);
          }
         } else {
           pos.fail("No such method ${name} found on protocol type ${base.name}");
         }
      }
      _ when base is FunctionType => pos.fail("Functions don't have fields")
      _ when base is VarArgsType => pos.fail("Var args type is illegal in this context")
      _ when base is TupleType => pos.fail("Tuples do not have methods at this time")
      _ when base is GenericType => {
        if (base.base is QualifiedType) {
          // delegate straight down. Should be no harm.
          return this.access(base.base, name, pos);
        }
      }
      _ when base is MetaType => {
        val metaQualified = base.base;

        if (metaQualified isNot QualifiedType) {
          pos.fail("Something is wrong, meta types should always contain qualified types in this context");
        }

        val meta = this.getTypeDef(base.base, pos);

        if (meta is DataType || meta is ProtocolType) {
         // this is how we look up static methods on data and protocol types.
         val sig = FunctionSignature{ isStatic: true, name };

         val methodMap = this.findMethods(metaQualified);

         if (methodMap != null) {
          val method = methodMap.methods.get(sig);

          if (method != null) {
            return (StaticAccess, method);
          }
         } else {
           pos.fail("No such method ${name} found on protocol type ${base.name}");
         }
        } else {
          pos.fail("Something is wrong, MetaType should only contain a DataType or a ProtocolType")
        }
      }
      _ => pos.fail("Cannot access on type ${rawBase}")
    }
  }

  fun fit(this, baseType: QualifiedType, targetType: QualifiedType, pos: Position): FitType = {
    val base = this.getType(baseType, pos);
    val target = this.getType(targetType, pos);

    if (base == null || target == null) {
      pos.fail("Unknown type");
    }

    if (baseType == targetType) {
      return PerfectFit;
    }

    if (target is ProtocolType) {
      val key = ProtocolImplPair{base: baseType, proto: targetType};

      val maybeProto = this.findProtoImpl(key);

      if (maybeProto != null) {
        return ProtocolFit{ impl: key };
      } else {
        pos.fail("Base type $baseType has no implementation of protocol $targetType");
      }
    }

    if (target is UnionType) {
      val fits = target.paramTypes.filter({ param => param == baseType});

      if (fits.isEmpty()) {
        pos.fail("Base type $baseType does not fit into target type $targetType");
      } else {
        return PerfectFit;
      }
    }

    if (target is IntersectionType) {
      pos.fail("I haven't implemented intersection types yet")
    }

    // does not fit
    pos.fail("Base type $baseType does not fit into target type $targetType");
  }
}

fun checkModule(module: AstModule): List[AstFile] = {
  val core = initCoreScope();

  val allFilesWithScopes = module.files.entries().map({ entry =>
    val (path, astFile) = entry;

    val fileScope = buildFileScope(core, path, astFile);

    return (fileScope, astFile);
  });

  val moduleTypeDefs = allFilesWithScopes.fold(Map.of(), { defs, pair =>
    val (fileScope) = pair;

    defs.concat(fileScope.typeDefs)
  });

  // bring all the type defs together into a single module scope
  val coreChild = core.child();
  val moduleScope = coreChild{typeDefs: moduleTypeDefs };

  val checkedFiles = allFilesWithScopes.map({ pair =>
    val (fileScope, astFile) = pair;

    // rewire the fileScope's parent to point through moduleScope

    val publicScope = fileScope.parent { parent: moduleScope };
    val privateScope = fileScope{ parent: publicScope }

    checkDeclarations(privateScope, astFile)
  })

  return allFilesWithScopes;
}

private fun buildFileScope(core: Scope, basePath: List[String], file: AstFile): Scope = {
  fun qualified(name: String): QualifiedType = {
    return QualifiedType { org: 'this', module: 'this', path: basePath.add(name) };
  }

  fun withScope(child: Scope, access: AccessModifier, action: { Scope -> Scope }): Scope = {
    if (access == Private) {
      return action(child);
    } else {
      val parent = action(child.parent);

      return child{parent};
    }
  }

  fun qualifiedType(scope: Scope, access: AccessModifier, name: String): Scope = {
    return withScope(scope, access, { level => level.setType(name, qualified(name)) });
  }

  // contains all the TYPES that are in scope, not the VALUES
  val lookup = file.declarations.fold(core.child().child(), { sum, next =>
    match (next) {
      _ when next is AtomDeclare => qualifiedType(sum, next.access, next.name)
      _ when next is DataDeclare => qualifiedType(sum, next.access, next.name)
      _ when next is TypeDeclare => qualifiedType(sum, next.access, next.type.name)
      _ when next is ImportDeclare => {
        val {org, module, path, name} = next.statement;
        sum.setType(name, QualifiedType { org, module, path } );
      }
      _ when next is ProtocolDeclare => next.pos.fail("Protocols are not implemented yet")
      _ => sum
    }
  });

  // set up all the qualified TYPES DEFS and VALUES now
  file.declarations.fold(lookup, { sum, next =>
    match (next) {
      _ when next is AtomDeclare => {
        // set value, the same as the type
        val withValue = withScope(sum, next.access, { scope => scope.setValue(next.name, qualified(next.name)) });
        // set the type def
        withScope(withValue, next.access, {scope => scope.setTypeDef(qualified(next.name), AtomType{name: next.name})})
      }
      _ when next is DataDeclare => {
        val key = qualified(next.name);
        val dataType = DataType { name: next.name, fields: next.body, typeParams: List.of() };

        // set the value, the MetaType
        val withValue = withScope(sum, next.access, { scope => scope.setValue(next.name, MetaType{base: key}) });
        // set the type def
        withScope(withValue, next.access, { scope => scope.setTypeDef(key, lookup.fullyQualify(dataType, next.pos)) })
      }
      _ when next is FunctionDeclare => {
        withScope(sum, next.access, { scope => scope.setValue(next.func.name, lookup.fullyQualify( next.func.body.type, next.pos )) })
      }
      _ when next is ImportDeclare => {
        val {org, module, path, name} = next.statement;
        sum.setValue(name, QualifiedType { org, module, path } );
      }
      _ when next is ConstantDeclare => withScope(sum, next.access, { scope => scope.setValue(next.assign.name, lookup.fullyQualify(next.assign.type, next.pos)) })
      _ when next is ImplDeclare => {
        if (next.proto != null) {
          next.pos.fail("Protocols are not implemented yet")
        } else {
          if (next.base isNot NamedType) {
            next.pos.fail("Only NamedTypes are supported right now")
          }

          val baseName = next.base.name;
          val qualifiedBase = lookup.getType(baseName)

          if (qualifiedBase isNot QualifiedType) {
            next.pos.fail("Only QualifiedType is expected here")
          }

          val dataScope = lookup.child().setType("This", qualifiedBase)
          val baseFuncPath = basePath.add(baseName);

          next.funcs
            .fold(sum, { innerSum, funDec =>
              val name = funDec.func.name;

              val location = QualifiedType { org: 'this', module: 'this', path: baseFuncPath.add(name) };

              val isStatic = funDec.func.body.args.size == 0 || funDec.func.body.args.head() != "this";
              val type = dataScope.fullyQualify(funDec.func.body.type, funDec.pos);

              val withMethod = withScope(innerSum, next.access, { scope => scope.setMethod(qualifiedBase, FunctionSignature{ isStatic, name}, location) })
              withScope(withMethod, next.access, {scope => scope.setTypeDef(location, type)})
          });
        }
      }
      _ => sum
    }
   })
}

private fun checkDeclarations(fileScope: Scope, file: AstFile): List[(QualifiedType, Declaration)] = {
  fun qualified(name: String): QualifiedType = {
    return QualifiedType { org: 'this', module: 'this', path: basePath.add(name) };
  }

  file.declarations.map({ dec =>
    match (dec) {
      _ when dec is AtomDeclare => (qualified(dec.name), dec)
      _ when dec is DataDeclare => {
        val qualifiedName = qualified(dec.name);

        val body = dec.body.entries().map({ pair =>
          val (key, rawType) = pair;
          val resolvedType = fileScope.fullyQualify(rawType, dec.pos);

          (key, resolvedType)
        });

        val result = dec{body};

        (qualifiedName, result)
      }
      _ when dec is TypeDeclare => {
        val name = qualified(dec.type.name);
        // add 'This' type before qualifying
        val value = fileScope.setType("This", name)
          .fullyQualify(dec.type.value);
        val type = dec.type{value};
        val result = dec{type};

        (name, result)
      }
      _ when dec is ConstantDeclare => {
        val name = qualified(dec.assign.name);
        val declaredType = fileScope.fullyQualify(dec.assign.type);



      }
      _ => dec
    }
  })
}

// this is not just checking a single statement because things like if's can rearrange the statements in a block
private fun checkBlock(blockScope: Scope, block: BlockExp): Expression = {

  // first we check for ifs with no else and turn the remainder of the block body into the else
  fun collapseIfs(body: List[Statement]): List[Statement] = {
    val ifWithoutElseIndex = body.findIndex({ state =>
      if (state is ExpressionStatement) {
        // flow typing can't ensure that state.ex is an IfExp, it only works on single variables, so we declare ex here
        val ex = state.ex

        ex is IfExp && ex.elseExp == null
      } else {
        false
      }
    });

    // if there was no match or if the match was the very last statement return
    if (ifWithoutElseIndex == -1 || ifWithoutElseIndex == body.size - 1) {
      return body;
    }

    val state = body.get(ifWithoutElseIndex)

    if (state isNot ExpressionStatement) {
      state.pos.fail("Impossible, we just checked this")
    }

    val ifEx = state.ex;

    if (ifEx isNot IfExp) {
      ifEx.pos.fail("Doubly impossible, we checked this too")
    }

    val init = body.slice(0, ifWithoutElseIndex)
    val elseExp = body.slice(ifWithoutElseIndex + 1, body.size)

    val result = init.add( ifEx{elseExp} )

    // recurse until there are no matches
    return collapseIfs(result);
  }

  val ifReducedBody = collapseIfs(block.body);

  fun foldBody(scope: Scope, next: Statement): (Scope, Statement) = {
    match(next) {
      _ when next is ExpressionStatement => {
        val ex = checkExpression(scope, next.ex);

        return (scope, next{ex});
     }
     _ when next is AssignmentStatement => {
       val {name, declaredType} = next;
       val resolvedDecType = scope.fullyQualify(declaredType, next.pos);

       val body = checkExpression(scope, next.body)

       if (body.type == UnknownType) {
        next.pos.fail("Unresolvable type")
       }

       if (resolvedDecType != UnknownType) {
        val fit = scope.fit(body.type, resolvedDecType, next.pos);

        match (fit) {
          _ when fit is PerfectFit => return (scope.setValue(name, resolvedDecType), next{ declaredType: resolvedDecType, body } )
          _ when fit is ProtocolFit => {
            val finalEx = WrapProtocolExp{ base: body, pos: next.pos, type: fit.impl.proto };

            return (scope.setValue(name, resolvedDecType), next{ declaredType: resolvedDecType, body: finalEx });
          }
        }
       } else {
        return (scope.setValue(name, body.type), next{ declaredType: body.type, body });
       }
     }
     _ when next is FunctionStatement => {
      val body = checkExpression(scope, next.body);

      return (scope.setValue(next.name, body.type), next{body});
     }
     _ when next is TypeStatement => {
      val type = scope.fullyQualify(next.type, next.pos);

      return (scope.setType(next.name, type), next{type});
     }
     _ when next is ImportStatement => {
      val {org, module, path, name} = next;
      val qualified = QualifiedType{ org, module, path };

      // this will throw if it wasn't found
      scope.getTypeDef(qualified, next.pos);

      val finalScope = scope.setType(name, qualified).setValue(name, qualified)

      return (finalScope, next)
     }
     _ when next is DeconstructDataStatement => {
       val base = checkExpression(scope, next.base);

       val qualifiedBase = scope.fullQualify(base.type, next.pos);
       val def = scope.getTypeDef(qualifiedBase, next.pos)

       if (def isNot DataType) {
        next.pos.fail("Destructure can only be used on tuples and data types")
       }

       val finalScope = next.values.fold(scope, { nextScope, next =>
          val (srcName, destName) = next;

          val (accessType, type) = nextScope.access(qualifiedBase, srcName, next.pos)

          if (accessType != FieldAccess) {
            next.pos.fail("No field named ${srcName} found");
          }

          nextScope.setValue(destName, type)
       });

       return (finalScope, next{base});
     }
     _ when next is DeconstructTupleStatement => {
      val base = checkExpression(scope, next.base);

      val def = scope.getTypeDef(scope.fullQualify(base.type, next.pos), next.pos);

      if (def isNot TupleType) {
        next.pos.fail("Tuple destructor can only be used on tuple")
      }

      if (def.typeParams.size < next.names.size) {
        next.pox.fail("Attempt to destructure more items in tuple than exist")
      }

      val finalScope = next.names.zip(def.typeParams).fold(scope, {nextScope, next =>
        val (name, type) = next;
        nextScope.setValue(name, type)
      });

      return (finalScope, next{base});
     }
     _ when next is DebuggerStatement => (scope, next)
    }
  }

  val (finalScope, body) = ifReducedBody.accumulate(blockScope, foldBody);

  val lastEx = {
    val lastEx = body.last();

    if (lastEx is DebuggerStatement) {
      // weird special case we need to handle - don't put two of these in a row
      body.init().last()
    } else {
      lastEx
    }
  };

  if (lastEx isNot ExpressionStatement)  {
    lastEx.pos.fail("Last statement in a block must be an expression")
  }

  val type = lastEx.ex.type;

  return block{ body, type }
}

private fun checkExpression(scope: Scope, ex: Expression): Expression = {
  match (ex) {
    _ when ex is LiteralExpression => (scope, ex) // literals always have the correct type
    _ when ex is IdentifierExp => {
      val type = scope.getValue(ex.name);

      ex{type}
    }
    _ when ex is BinaryOpExp => {
      // for now at least we're hard coding our basic ops
      match (ex.op) {
        // these only work on two numbers of the same type
        "+" => checkMathOp(scope, ex)
        "-" => checkMathOp(scope, ex)
        "*" => checkMathOp(scope, ex)
        "/" => checkMathOp(scope, ex)

        // same for these
        ">" => checkMathOp(scope, ex)
        ">=" => checkMathOp(scope, ex)
        "<" => checkMathOp(scope, ex)
        "<=" => checkMathOp(scope, ex)

        // for now these can work on ANY types
        "==" => ex{ left: checkExpression(scope, ex.left), right: checkExpression(scope, ex.right), type: BooleanType }
        "!=" => ex{ left: checkExpression(scope, ex.left), right: checkExpression(scope, ex.right), type: BooleanType }

        // these guys check for a type on the right side, not a value
        "is" => checkIsOp(scope, ex)
        "isNot" => checkIsOp(scope, ex)

        // and these two perform type assertions as they go
        "&&" => checkAndOp(scope, ex)
        "||" => checkOrOp(scope, ex)
        _ => ex.pos.fail("Invalid operator ${ex.op}")
      }
    }
    _ when ex is UnaryOpExp => {
      match (ex.op) {
        "-" => {
          val base = checkExpression(scope, ex.ex);

          val type = match (base.type) {
            FloatType => FloatType
            IntType => IntType
            _ => ex.pos.fail("Unary ''-' can only be applied to floats or ints")
          }

          ex{ex: base, type}
        }
        "!" => {
          val base = checkExpression(scope, ex.ex);

          if (base.type != BooleanType) {
            ex.pos.fail("'!' operator can only be applied to boolean expressions")
          }

          ex{ex: base, type: BooleanType}
        }
      }
    }
    _ when ex is BlockExp => checkBlock(scope.child(), ex)
    _ when ex is FieldAccessExp => checkAccess(scope, ex)
    _ when ex is CallExp => {
      val func = checkExpression(scope, ex.func)

      if (func isNot FunctionType) {
        ex.pos.fail("Attempt to call non-function");
      }


    }
  }
}

private fun checkMathOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  // must be the same type: ie: both ints or both floats

  val left = checkExpression(scope, base.left);
  val right = checkExpression(scope, base.right);

  if (left.type != right.type) {
    base.pos.fail("Binary expression must be both ints or both floats, instead found left: ${left.type} and right: ${right.type}");
  }

  val type = match (left.type) {
    IntType => { IntType }
    FloatType => { FloatType }
    _ => base.pos.fail("Binary expression must be both ints or both floats, instead found left: ${left.type} and right: ${right.type}")
  }

  return base{left, right, type};
}

private fun checkIsOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  // left side is variable but right is type. Works for both is and isNot

  val left = checkExpression(scope, base.left);
  val rawRight = base.right;

  if (rawRight is IdentifierExp) {
    val rightType = scope.getType(rawRight.name, rawRight.pos);
    val right = rawRight{type: rightType};

    return base{left, right, type: BooleanType};
  } else {
    base.pos.fail("Right side of ${base.op} expression must be a type identifier")
  }
}

private fun checkAndOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  val left = checkExpression(scope, base.left);

  if (left.type != BooleanType) {
    base.pos.fail("Expected boolean expression left of &&");
  }

  val {whenTrue} = flowSensitiveAnalysis(scope, left);

  val right = checkExpression(whenTrue, base.right);

  if (right.type != BooleanType) {
    base.pos.fail("Expected boolean expression right of ||");
  }

  base{ left, right, type: BooleanType }
}

private fun checkOrOp(scope: Scope, base: BinaryOpExp): BinaryOpExp = {
  val left = checkExpression(scope, base.left);

  if (left.type != BooleanType) {
    base.pos.fail("Expected boolean expression left of &&");
  }

  val {whenFalse} = flowSensitiveAnalysis(scope, left);

  val right = checkExpression(whenFalse, base.right);

  if (right.type != BooleanType) {
    base.pos.fail("Expected boolean expression right of ||");
  }


  base{ left, right, type: BooleanType }
}

private fun checkAccess(scope: Scope, access: FieldAccessExp): FieldAccessExp = {
  val base = checkExpression(scope, access.base);

  val name = base.name;

  val (accessType, type) = scope.access(base.type, name, access.pos);

  access{base, type}
}

data FlowScope = { whenTrue: Scope, whenFalse: Scope }

private fun flowSensitiveAnalysis(baseScope: Scope, ex: Expression): FlowScope = {
  // assume ex has been properly typed

  match (ex) {
    _ when ex is BinaryOpExp => {
      match (ex.op) {
        "is" => doIsTypeAssertion(baseScope, ex)
        "isNot" => {
          // literally the same as 'is' just reversed outcomes
          val {whenTrue: whenFalse, whenFalse: whenTrue} = doIsTypeAssertion(baseScope, ex);
          FlowScope{ whenTrue, whenFalse }
        }
        "&&" => {
          val {whenTrue: prevWhenTrue, whenFalse} = flowSensitiveAnalysis(baseScope, ex.left);

          // pass only the true result into the right side, return it's value
          val {whenTrue} = flowSensitiveAnalysis(prevWhenTrue, ex.right)

          FlowScope{ whenFalse, whenTrue }
        }
        "||" => {
          val {whenFalse: prevWhenFalse, whenTrue} = flowSensitiveAnalysis(baseScope, ex.left);

          // the reverse of &&, pass only the false result into the right side, return it's value
          val {whenFalse} = flowSensitiveAnalysis(prevWhenFalse, ex.right)

          FlowScope{ whenTrue, whenFalse }
        }
        _ => FlowScope{ whenTrue: baseScope, whenFalse: baseScope }
      }
    }
    _ => FlowScope{ whenTrue: baseScope, whenFalse: baseScope }
  }
}

private fun doIsTypeAssertion(baseScope: Scope, ex: BinaryOpExp): FlowScope = {
  val left = ex.left;
  val right = ex.right;

  if (left is IdentifierExp && right is IdentifierExp) {
    val rawType = left.type;

    val whenTrue = baseScope.setValue(left.name, right.type);
    val whenFalse = if (rawType is UnionType) {
      // if the left side is a union, we now know that it can't be the right type, so remove that from the union
      val paramTypes = rawType.paramTypes.filter({ it => it != right.type})

      val assertedType = if (paramTypes.size == 1) {
        paramTypes.get(0)
      } else {
        UnionType{paramTypes}
      }

      baseScope.setValue(left.name, assertedType)
    } else {
      baseScope
    }

    FlowScope{ whenTrue, whenFalse }
  } else {
    FlowScope{ whenTrue: baseScope, whenFalse: baseScope }
  }
}

private fun resolveFunction(scope: Scope, func: FunctionType, arguments: List[Expression]): (FunctionType, List[Expression]) = {
  val typedArgs = arguments.map({ next => checkExpression(scope, next) });

  val fullFunc = if (func.typeParams.isEmpty()) {
    func
  } else {

  }
}

private fun resolveGenerics(typeScope: Map[String, Type], genType: Type, fullType: Type, pos: Position): Map[String, Type] = {
  match (genType) {
    _ when genType is PlaceholderType => {
      val name = genType.name;

      if (typeScope.contains(name)) {
        val existing = typeScope.get(name)

        fit()
      }
    }
    _ when genType is GenericType => {
      if (fullType is GenericType) {
        if (genType.typeParams.size == fullType.typeParams.size) {
          val (scopeWithBase, base) = resolveGenerics(typeScope, genType.base, fullType.base, pos);

          genType.typeParams.zip(fullType.typeParams).fold(scopeWithBase, { scope, next =>
            val (gen, full) = next;

            resolveGenerics(scope, gen, full, pos)
          });
        } else {
          pos.fail("Generic types of function and arguments don't match");
        }
      } else {
        pos.fail("Arguments don't match function")
      }
    }
    _ when genType is TupleType => {
      if (fullType is TupleType) {
        if (genType.typeParams.size == fullType.typeParams.size) {
          genType.typeParams.zip(fullType.typeParams).fold(typeScope, { scope, next =>
            val (gen, full) = next;

            resolveGenerics(scope, gen, full, pos)
          });
        } else {
          pos.fail("Function and arguments both have tuple but arity doesn't match");
        }
      } else {
        pos.fail("Arguments don't match function")
      }
    }

  }
}
