import this/Lexer.Position

import this/Ast.AccessModifier
import this/Ast.Public
import this/Ast.Protected
import this/Ast.Internal
import this/Ast.Private

import this/Ast.NullLiteralExp
import this/Ast.BooleanLiteralExp
import this/Ast.NumberLiteralExp
import this/Ast.StringLiteralExp
import this/Ast.ListLiteralExp
import this/Ast.CharLiteralExp
import this/Ast.IdentifierExp
import this/Ast.BinaryOpExp
import this/Ast.UnaryOpExp
import this/Ast.BlockExp
import this/Ast.CallExp
import this/Ast.LambdaExp
import this/Ast.IfExp
import this/Ast.ReturnExp
import this/Ast.ThrowExp
import this/Ast.ConstructExp
import this/Ast.ConstructTupleExp
import this/Ast.MatchExp
import this/Ast.Expression
import this/Ast.Statement
import this/Ast.ExpressionStatement
import this/Ast.AssignmentStatement
import this/Ast.FunctionStatement
import this/Ast.TypeStatement
import this/Ast.ImportStatement
import this/Ast.DeconstructDataStatement
import this/Ast.DeconstructTupleStatement
import this/Ast.DebuggerStatement
import this/Ast.Declaration
import this/Ast.AtomDeclare
import this/Ast.DataDeclare
import this/Ast.TypeDeclare
import this/Ast.FunctionDeclare
import this/Ast.ImportDeclare
import this/Ast.ConstantDeclare
import this/Ast.ProtocolDeclare
import this/Ast.ImplDeclare
import this/Ast.MatchPattern
import this/Ast.AstModule
import this/Ast.AstPackage

import this/Type.PrimitiveType
import this/Type.AtomType
import this/Type.DataType
import this/Type.ProtocolType
import this/Type.FunctionType
import this/Type.TupleType
import this/Type.GenericType
import this/Type.UnknownType
import this/Type.NamedType
import this/Type.ImportedType
import this/Type.PlaceholderType
import this/Type.UnionType
import this/Type.IntersectionType
import this/Type.CharType
import this/Type.StringType
import this/Type.IntType
import this/Type.FloatType
import this/Type.BooleanType
import this/Type.AnyType
import this/Type.NullType
import this/Type.UnitType
import this/Type.NothingType
import this/Type.ListType
import this/Type.MapType
import this/Type.Type

data PackageScope = { env: Map[String, PackageScope], values: Map[List[String], (AccessModifier, Type)] }

implement PackageScope {
  fun lookupImport(this, ex: ImportStatement, currentPath: List[String]): Type = {
    val { packageName, modulePath, pos} = ex;

    if (packageName == 'this') {
      val item = this.values.get(modulePath);

      if (item == null) {
        pos.fail("${ item.join('.') } does not exist")
      }

      val (itemAccess, itemType) = item

      val isAccessible = match (itemAccess) {
        Public => true
        Internal => true
        Private => false
        Protected => currentPath.size() >= modulePath.size() && modulePath.zip(currentPath).all({ left, right => left == right })
      }

      if (isAccessible) {
        return itemType;
      } else {
        pos.fail("${ item.join('.') } is not accessible here")
      }
    } else {
      val package = this.env.get(packageName)

      if (package == null) {
        pos.fail("No such package '$packageName' found")
      }

      val item = package.values.get(modulePath)

      if (item == null) {
        pos.fail("${ item.join('.') } is not a valid public member of $packageName")
      }

      val (itemAccess, itemType) = item;

      if (itemAccess == Public) {
        return itemType
      } else {
        pos.fail("${ item.join('.') } is not a valid public member of $packageName")
      }
    }
  }

  fun insertDeclaration(this, modulePath: List[String], access: AccessModifier, type: Type): PackageScope = {
    this{values: this.values.set(modulePath, (access, type))}
  }
}

data Scope = { values: Map[String, Type], parent: Scope }

implement Scope {

  fun get(this, name: String, pos: Position): Type = {
    if (this.values.contains(name)) {
      return this.values.get(name)
    } else {
      if (this.parent != null) {
        return this.parent.get(name, pos)
      } else {
        pos.fail("Unknown type $name is not in scope")
      }
    }
  }

  fun set(this, name: String, type: Type): Scope = this{values: this.values.set(name, type)}
}

fun initScope(): Scope = Scope { values: Map.of(), parent: null }

fun checkPackage(pack: AstPackage, env: Map[String, PackageScope]): PackageScope = {
  val packageScope = PackageScope { env, values: Map.of() }

  val namesOnly = pack.modules.entries().fold(packageScope, { pack, pair =>
    val (modulePath, module) = pair

    val (scope, pack) = populateNames(modulePath, module, pack);
    pack
  });

  return namesOnly;
}

private fun populateNames(moduleBase: List[String], module: AstModule, initPackage: PackageScope): (Scope, PackageScope) = {
  val scope = module.declarations.fold(initScope(), { scope, dec =>
    if (dec is ImportDeclare) {
      val { packageName, modulePath } = dec.statement;
      scope.set(modulePath.last(), ImportedType { packageName, modulePath })
    } else {
      scope
    }
  });

  fun applyImports(src: Type): Type = {
    match (src) {
      _ when src is DataType => src{ fields: Map.from(src.fields.entries().map({ pair => val (key, value) = pair; (key, applyImports(value)) })) }
      _ when src is FunctionType => src{ paramTypes: src.paramTypes.map(applyImports), resultType: applyImports(src.resultType) }
      _ when src is TupleType => TupleType { paramTypes: src.paramTypes.map(applyImports) }
      _ when src is GenericType => GenericType { base: applyImports(src.base), paramTypes: src.paramTypes.map(applyImports) }
      _ when src is UnionType => UnionType { paramTypes: src.paramTypes.map(applyImports) }
      _ when src is IntersectionType => IntersectionType { paramTypes: src.paramTypes.map(applyImports) }
      _ when src is NamedType => {
        val maybe = scope.values.get(src.name)

        if (maybe == null) src else maybe
      }
      _ => src
    }
  }

  val finalPack = module.declarations.fold(initPackage, { pack, dec =>
    match (dec) {
      _ when dec is AtomDeclare => pack.insertDeclaration( moduleBase.add(dec.name), dec.access, AtomType{name: dec.name} )
      _ when dec is DataDeclare => pack.insertDeclaration ( moduleBase.add(dec.name), dec.access, applyImports(DataType { name: dec.name, fields: dec.body, typeParams: List.of() }) )
      _ when dec is TypeDeclare => pack.insertDeclaration ( moduleBase.add(dec.type.name), dec.access, applyImports(dec.type.value) )
      _ when dec is FunctionDeclare => pack.insertDeclaration ( moduleBase.add(dec.func.name), dec.access, applyImports(dec.func.body.type) )
      _ when dec is ImportDeclare => pack
      _ when dec is ConstantDeclare => pack.insertDeclaration ( moduleBase.add(dec.assign.name), dec.access, applyImports(dec.assign.body.type) )
      _ when dec is ProtocolDeclare => dec.pos.fail("Protocols are not yet supported")
      _ when dec is ImplDeclare => {
        val baseName = if ( dec.base is NamedType ) dec.base.name else dec.pos.fail("Something is very wrong. Type checker expects the parser to always produce NamedType for the base of an ImplDeclare")

        if ( dec.proto != null ) {
          dec.pos.fail("Protocols are not yet supported")
        }

        dec.funcs.fold(pack, { pack, func =>
          val funcName = "$baseName.${func.func.name}"

          pack.insertDeclaration( moduleBase.add(funcName), func.access, applyImports(func.func.body.type) )
        });
      }
    }
  })

  return (scope, finalPack);
}

