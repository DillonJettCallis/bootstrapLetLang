atom CharType
atom StringType
atom IntType
atom FloatType
atom BooleanType
atom AnyType
atom NullType
atom UnitType
atom NothingType

atom ListType
atom SetType
atom MapType
atom FileType

type PrimitiveType
    = CharType
    | StringType
    | IntType
    | FloatType
    | BooleanType
    | AnyType
    | NullType
    | UnitType
    | NothingType

data QualifiedName = { org: String, module: String, path: List[String] }

implement QualifiedName {
  fun pretty(this): String = "${this.org}::${this.module}/${path.join( { it => it } )}"
}

data AtomType = { name: String, qualified: QualifiedName }
data DataType = { name: String, fields: Map[String, Type], typeParams: List[PlaceholderType], qualified: QualifiedName }
data ProtocolType = { name: String, functions: Map[String, Type], typeParams: List[PlaceholderType], qualified: QualifiedName }
data FunctionType = { paramTypes: List[Type], varargType: List[Type], resultType: Type, typeParams: List[PlaceholderType] }
data TupleType = { paramTypes: List[Type] }
data GenericType = { base: DateType | ProtocolType, paramTypes: List[Type] }

data MetaType = { base: DateType | ProtocolType }


atom UnknownType

data NamedType = { name: String }
data PlaceholderType = { name: String }

data UnionType = { paramTypes: List[Type] }
data IntersectionType = { paramTypes: List[Type] }

fun makeUnionType(left: Type , right: Type ): UnionType = {
  val leftList = unwrapUnionType(left)
  val rightList = unwrapUnionType(right)
  UnionType{ paramTypes: leftList.concat(rightList) }
}

private fun unwrapUnionType(type: Type): List[Type] = if (type is UnionType) type.paramTypes else List.of(type)

fun makeIntersectionType(left: Type, right: Type): IntersectionType = {
  val leftList = unwrapIntersectionType(left)
  val rightList = unwrapIntersectionType(right)
  IntersectionType{ paramTypes: leftList.concat(rightList) }
}

private fun unwrapIntersectionType(type: Type): List[Type] = if (type is IntersectionType) type.paramTypes else List.of(type)

type Type
    = PrimitiveType
    | AtomType
    | DataType
    | MetaType
    | ProtocolType
    | FunctionType
    | TupleType
    | GenericType
    | UnknownType
    | NamedType
    | PlaceholderType
    | UnionType
    | IntersectionType

fun listOfType(item: Type): GenericType = GenericType{ base: ListType, paramTypes: List.of(item) }

val stringTemplateType: FunctionType = FunctionType {
  paramTypes: List.of(listOfType(StringType), listOfType(AnyType)),
  resultType: StringType
}

