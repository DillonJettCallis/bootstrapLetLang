fun main(args: List[String]): Unit = {
  if (args.isEmpty()) {
    println('Invalid arguments. Expected just one source file for now.')
  } else {
    val fileName = args.head()
    val tokens = lex(fileName, File.fromPath(fileName).readText())
    println("Tokens: ${tokens}")
  }
}

// org

atom PublicAccess
atom ProtectedAccess
atom InternalAccess
atom PrivateAccess


// types

atom BooleanType
atom IntType
atom CharType
atom ListType
atom MapType


atom UnknownType


  fun isEmpty(): Boolean = tokens.size < index
  fun isNotEmpty(): Boolean = tokens.size >= index
  fun curr(): Char = raw.get(index)
  fun prev(): Char = raw.get(index - 1)
  fun peek(): Char = raw.get(index + 1)
  fun skip(): StringCursor = this{index: index + 1}
  fun next(): (StringCursor, Char) = {
    val next = skip()
    (next, next.curr())
  }


fun parseModule(name: String, tokens: List[Token]): ModuleDeclare = {
  val cursor = ParseCursor{tokens, index: -1}

  val declarations = parseDeclarations(cursor, List.of(), null)
    .keyBy({ dec => dec.name })

  ModuleDeclare{name, declarations}
}

private fun parseDeclarations(cursor: ParseCursor, declarations: List[Declaration], access: AccessModifier): List[Declaration] = {
  if (cursor.isEmpty) {
    declarations
  } else {
    val (nextCursor, nextToken) = cursor.next()

    if (nextToken is TokenWord) {
      match (nextToken.value) {
        'val' => declarations.add(ConstDeclare{access, assignment: parseAssignment(nextCursor)})

        'private' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, PrivateAccess) else throw Error.new('use of multiple access modifier')
        'protected' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, ProtectedAccess) else throw Error.new('use of multiple access modifier')
        'internal' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, InternalAccess) else throw Error.new('use of multiple access modifier')
        'public' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, PublicAccess) else throw Error.new('use of multiple access modifier')
      }
    } else {
      throw Error.new('Syntax error: Expected word but found $next')
    }
  }
}


/**
 * Assume 'val' has already been parsed
 */
private fun parseAssignment(cursor: ParseCursor): ValueDeclare = {
  val pos = cursor.curr().pos
  val (nameCursor, nameToken) = cursor.next()

  if (nameToken is TokenWord) {
    val name = nameToken
    val (equalsCursor, equalsToken) = nameCursor.next()

    if (equalsToken is TokenSymbol && equalsToken.value == '=') {
      val expression = parseExpression(equalsCursor)

      return ValueDeclare{name, expression, pos}
    } else {
      equalsToken.pos.fail("Expected '=', found ${equalsToken.value}")
    }

  } else {
    nameToken.pos.fail('Expected assignment identifier')
  }
}

/**
 * Assume 'fun' has already been parsed
 */
private fun parseFunction(cursor: ParseCursor): FunctionDeclare = {
  val pos = cursor.curr().pos
  val (maybeGenericsCursor, maybeGenericsToken) = cursor.next()

  if (maybeGenericsToken is TokenSymbol && maybeGenericsToken.value == '[') {

  }
}

// lexer

  fun isEmpty(): Boolean = raw.size < index
  fun isNotEmpty(): Boolean = raw.size >= index
  fun curr(): Char = raw.getCharAt(index)
  fun prev(): Char = raw.getCharAt(index - 1)
  fun peek(): Char = raw.getCharAt(index + 1)
  fun skip(): StringCursor = if (index == -1) this{index: index + 1} else this{index: index + 1, pos: pos.increment(curr())}
  fun next(): (StringCursor, Char) = {
    val next = skip()
    (next, next.curr())
  }

  fun increment(next: Char): Position = if (next == char'\n') this{line: line + 1, col: 0} else this{col: col + 1}
  fun fail(message: String): Nothing = throw Error.new("$message at ${this.line}:${this.col} in ${this.src}")


private val lowerCase = 'abcdefghijklmnopqrstuvwxyz'
private val upperCase = lowerCase.toUpperCase()
private val letters = lowerCase.append(upperCase)
private val digitStart = '0123456789'
private val digitContinue = digitStart.append('.')
private val wordStart = letters
private val wordContinue = letters.append(digitStart)
private val quoteChars = "'\"`"
private val whitespace = '\s\t\r\n'
private val lineComment = '//'
private val blockCommentStart = '/*'
private val blockCommentEnd = '*/'
private val singletonSymbols = '({[]})_,;' // these symbols are always alone. They can start but never continue
private val mergedSymbols = '=<>!-+/*:.&|' // these symbols merge with one another to form compound symbols
private val symbolStart = mergedSymbols.append(singletonSymbols)
private val symbolEnd = mergedSymbols

fun lex(src: String, raw: String): List[Token] = {
  val src = StringCursor{ raw, index: -1, pos: Position{ line: 1, col: 1, src } }

  muncher(src, List.of())
}

private fun muncher(src: StringCursor, result: List[Token]): List[Token] = {
  if (src.isEmpty()) return result

  val (nextCursor, nextChar) = src.next()

  match (nextChar) {
    // checking for comments, both block and line
    char'/' when nextCursor.isNotEmpty() && '/*'.contains(nextCursor.peek()) => {
      match (nextCursor.peek()) {
        char'/' => return muncher(munchLineComment(nextCursor), result)
        char'*' => return muncher(munchBlockComment(nextCursor), result)
      }
    }
    // check for number. Do not bother with making sure there is at most one decimal point yet.
    _ when digitStart.contains(nextChar) => {
      val (finalCursor, value) = munchDigit(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenWord {value, pos: nextCursor.pos }))
    }
    // lex any words
    _ when wordStart.contains(nextChar) => {
      val (finalCursor, value) = munchWord(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenNumber {value, pos: nextCursor.pos }))
    }
    // lex strings of any quote type
    _ when quoteChars.contains(nextChar) => {
      val (finalCursor, value) = munchString(nextCursor, "", nextChar)

      return muncher(finalCursor, result.add(TokenString{ value, pos: nextCursor.pos }))
    }
    // lex symbols
    _ when symbolStart.contains(nextChar) => {
      val (finalCursor, value) = munchSymbol(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenSymbol{ value, pos: nextCursor.pos }))
    }
    // handle whitespace
    _ when whitespace.contains(nextChar) => {
      return muncher(nextCursor, result)
    }
    _ => throw Error.new('Unexpected character $nextChar')
  }
}

private fun munchDigit(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, digitContinue)

private fun munchWord(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, wordContinue)

private fun munchSymbol(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, symbolEnd)

private fun munchContinuation(src: StringCursor, working: String, continuation: String): (StringCursor, String) = {
  val (nextCursor, nextChar) = src.next()

  if (continuation.contains(nextChar)) {
    // tail recursion
    munchContinuation(nextCursor, working.append(nextChar), continuation)
  } else {
    (src, working)
  }
}

/**
 * Munch the string, looking for the openType.
 * Do NOT process escapes or interpolation but DO allow escaped chars to pass through.
 */
private fun munchString(src: StringCursor, working: String, openType: Char): (StringCursor, String) = {
  val (nextCursor, nextChar) = src.next()

  // there is one close quote, maybe we are at the end
  match (nextChar) {
    openType => (nextCursor, working)
    char'\\' => { // something is escaped. Don't look at it, just pass both along no matter what.
      val (final, escapedChar) = nextCursor.next()

      munchString(final, working.append(nextChar).append(escapedChar), openType)
    }
    _ => munchString(nextCursor, working.append(nextChar), openType)
  }
}

private fun munchLineComment(src: StringCursor): StringCursor = {
  doUntil(src, { cur => cur.skip() } , { it => it.curr() == char'\n' })
}

private fun munchBlockComment(src: StringCursor): StringCursor = {
  doUntil(src, { cur => cur.skip() } , { it => it.curr() == char'*' && it.isNotEmpty() && it.peek() == char'/' })
}

private fun doUntil[Item](init: Item, action: { Item -> Item }, test: { Item -> Boolean }): Item =
  if (test(init)) init else doUntil(action(init), action, test)




