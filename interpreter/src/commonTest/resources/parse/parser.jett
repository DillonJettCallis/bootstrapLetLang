import this/position.Position

import this/parse.lexer.Token
import this/parse.lexer.TokenWord
import this/parse.lexer.TokenSymbol
import this/parse.lexer.TokenString
import this/parse.lexer.TokenNumber

import this/access.AccessModifier
import this/access.Public
import this/access.Protected
import this/access.Internal
import this/access.Private

import this/parse.parseAst.ParseAssignmentStatement
import this/parse.parseAst.ParseFile
import this/parse.parseAst.ParseAtomDeclare
import this/parse.parseAst.ParseBinaryOpExp
import this/parse.parseAst.ParseBlockExp
import this/parse.parseAst.ParseBooleanLiteralExp
import this/parse.parseAst.ParseCallExp
import this/parse.parseAst.ParseCharLiteralExp
import this/parse.parseAst.ParseConstantDeclare
import this/parse.parseAst.ParseConstructExp
import this/parse.parseAst.ParseConstructTupleExp
import this/parse.parseAst.ParseDataDeclare
import this/parse.parseAst.ParseDebuggerStatement
import this/parse.parseAst.ParseDeclaration
import this/parse.parseAst.ParseDeconstructDataStatement
import this/parse.parseAst.ParseDeconstructTupleStatement
import this/parse.parseAst.ParseExpression
import this/parse.parseAst.ParseExpressionStatement
import this/parse.parseAst.ParseFieldAccessExp
import this/parse.parseAst.ParseFunctionDeclare
import this/parse.parseAst.ParseFunctionStatement
import this/parse.parseAst.ParseIdentifierExp
import this/parse.parseAst.ParseIfExp
import this/parse.parseAst.ParseImplDeclare
import this/parse.parseAst.ParseImportDeclare
import this/parse.parseAst.ParseImportStatement
import this/parse.parseAst.ParseLambdaExp
import this/parse.parseAst.ParseMatchExp
import this/parse.parseAst.ParseMatchPattern
import this/parse.parseAst.ParseMethodCallExp
import this/parse.parseAst.ParseNullLiteralExp
import this/parse.parseAst.ParseNumberLiteralExp
import this/parse.parseAst.ParseProtocolDeclare
import this/parse.parseAst.ParseReturnExp
import this/parse.parseAst.ParseStatement
import this/parse.parseAst.ParseStringLiteralExp
import this/parse.parseAst.ParseThrowExp
import this/parse.parseAst.ParseTypeDeclare
import this/parse.parseAst.ParseTypeStatement
import this/parse.parseAst.ParseUnaryOpExp

import this/type.typeExpression.GenericTypeExp
import this/type.typeExpression.IntersectionTypeExp
import this/type.typeExpression.FunctionTypeExp
import this/type.typeExpression.NamedTypeExp
import this/type.typeExpression.TupleTypeExp
import this/type.typeExpression.TypeExpression
import this/type.typeExpression.UnionTypeExp

import this/parse.stringTemplate.parseStringTemplateWithPrefix


private data TokenCursor { tokens: List[Token], index: Int }

implement TokenCursor {

  fun isEmpty(this): Boolean = this.index + 1 >= this.tokens.size
  fun curr(this): Token = this.tokens.get(this.index)
  fun skip(this): TokenCursor = this{index: this.index + 1}
  fun next(this): (TokenCursor, Token) = (this.skip(), this.curr())

}

fun parse(path: List[String], tokens: List[Token]): ParseFile = {
  val cursor = TokenCursor{ tokens, index: 0 }

  parseFile(path, cursor, List.of())
}

fun parseExpressionOnly(tokens: List[Token]): ParseExpression = {
  val cursor = TokenCursor{ tokens, index: 0 }

  val (final, result) = parseExpression(cursor)

  result
}

private fun parseFile(path: List[String], cursor: TokenCursor, declarations: List[ParseDeclaration]): ParseFile = {
  if (cursor.isEmpty()) {
    return ParseFile{ path, declarations }
  } else {
    val (nextCursor, token) = cursor.next()

    match (token) {
      _ when token is TokenWord => {
        val (finalCursor, dec) = match (token.value) {
          "private" => parseDeclaration(nextCursor, Private)
          "internal" => parseDeclaration(nextCursor, Internal)
          "protected" => parseDeclaration(nextCursor, Protected)
          "public" => parseDeclaration(nextCursor, Public)
          _ => parseDeclaration(cursor, Internal)
        }

        return parseFile(path, finalCursor, declarations.add(dec))
      }

      _ => token.pos.fail('Expected declaration')
    }
  }
}

private fun parseDeclaration(cursor: TokenCursor, access: AccessModifier): (TokenCursor, ParseDeclaration) = {
  val (nextCursor, curr) = cursor.next()
  val pos = curr.pos

  if (curr is TokenWord) {
    match (curr.value) {
      "val" => return parseConstDeclare(nextCursor, access, pos)
      "atom" => return parseAtomDeclare(nextCursor, access, pos)
      "fun" => return parseFunctionDeclare(nextCursor, access, pos)
      "data" => return parseDataDeclare(nextCursor, access, pos)
      "type" => return parseTypeDeclare(nextCursor, access, pos)
      "import" => return parseImportDeclare(nextCursor, pos)
      "protocol" => pos.fail("Not yet implemented")
      "implement" => return parseImplDeclare(nextCursor, access, pos)
      _ => pos.fail("Expected declaration but found `${curr.value}` ")
    }
  } else {
    pos.fail("Expected declaration but found `${curr}` ")
  }
}

private fun parseConstDeclare(cursor: TokenCursor, access: AccessModifier, pos: Position): (TokenCursor, ParseConstantDeclare) = {
  val (assignCursor, assign) = parseSingleAssignmentStatement(cursor, pos)

  val type = assign.declaredType

  if (type == null) {
    assign.pos.fail("Constants must declare their type")
  }

  return (assignCursor, ParseConstantDeclare{assign, access, pos})
}

private fun parseAtomDeclare(cursor: TokenCursor, access: AccessModifier, pos: Position): (TokenCursor, ParseAtomDeclare) = {
  val (finalCursor, token) = cursor.next()

  if (token is TokenWord) {
    return (finalCursor, ParseAtomDeclare{name: token.value, access, pos})
  } else {
    token.pos.fail("Expected type")
  }
}

private fun parseTypeDeclare(cursor: TokenCursor, access: AccessModifier, pos: Position): (TokenCursor, ParseTypeDeclare) = {
  val (finalCursor, statement) = parseTypeStatement(cursor, pos)

  return (finalCursor, ParseTypeDeclare{type: statement, access, pos})
}

private fun parseTypeStatement(cursor: TokenCursor, pos: Position): (TokenCursor, ParseTypeStatement) = {
  val (nameCursor, nameToken) = cursor.next()

  if ( nameToken isNot TokenWord ) {
    nameToken.pos.fail("Expected name of type")
  }

  val name = nameToken.value

  val (equalsCursor, equals) = nameCursor.next()

  if (equals isNot TokenSymbol || equals.value != "=") {
    equals.pos.fail("Expected type assignment")
  }

  val (typeCursor, type) = parseType(equalsCursor)

  return (typeCursor, ParseTypeStatement{name, value: type, pos})
}

private fun parseImportDeclare(cursor: TokenCursor, pos: Position): (TokenCursor, ParseImportDeclare) = {
  val (finalCursor, statement) = parseImportStatement(cursor, pos)

  return (finalCursor, ParseImportDeclare{statement, pos, access: Private})
}

private fun parseImportStatement(cursor: TokenCursor, pos: Position): (TokenCursor, ParseImportStatement) = {
  val (orgCursor, orgToken) = cursor.next()

  if (orgToken isNot TokenWord) {
    orgToken.pos.fail("Expected import package name")
  }

  val orgName = orgToken.value

  val (slashCursor, slash) = orgCursor.next()

  if (slash isNot TokenSymbol || slash.value != "/") {
    slash.pos.fail("Expected import package module delimiter '/'")
  }

  fun parseImportPath(cursor: TokenCursor, init: List[String]): (TokenCursor, List[String], String) = {
    val (nextCursor, nextToken) = cursor.next()

    if (nextToken isNot TokenWord) {
      nextToken.pos.fail("Expected module path in import")
    }

    val result = init.add(nextToken.value);

    val maybeDot = nextCursor.curr()

    return if (maybeDot is TokenSymbol && maybeDot.value == ".") {
      parseImportPath(nextCursor.skip(), result)
    } else {
      (nextCursor, result, nextToken.value)
    }
  }

  val (maybeModuleCursor, maybeModule) = slashCursor.next()

  if (maybeModule isNot TokenWord) {
    maybeModule.pos.fail("Expected module name in import")
  }

  val (maybeSlashCursor, maybeSlash) = maybeModuleCursor.next()

  val (moduleName, finalCursor, path, name) = if (maybeSlash is TokenSymbol && maybeSlash.value == "/") {
    // this is a fully qualified import, nothing special to do
    val (finalCursor, path, name) = parseImportPath(maybeSlashCursor, List.of());
    (maybeModule.value, finalCursor, path, name)
  } else {
    if (orgName == "this") {
      val (finalCursor, path, name) = parseImportPath(slashCursor, List.of());
      ("this", finalCursor, path, name)
    } else {
      maybeSlash.pos.fail("Only a 'this' import can skip the org name")
    }
  }

  return (finalCursor, ParseImportStatement{org: orgName, module: moduleName, path, name, pos})
}

private fun parseDataDeclare(cursor: TokenCursor, access: AccessModifier, pos: Position): (TokenCursor, ParseDataDeclare) = {
  val (nameCursor, nameToken) = cursor.next()

  if (nameToken isNot TokenWord) {
    nameToken.pos.fail("Expected name of data structure")
  }

  val name = nameToken.value

  val (openCursor, open) = nameCursor.next()

  if (open isNot TokenSymbol || open.value != "{") {
    nameToken.pos.fail("Expected data declaration open bracket")
  }

  val (finalCursor, fields) = parseDataField(openCursor, Map.of[String, TypeExpression]())

  return (finalCursor, ParseDataDeclare{name, generics: List.of(), body: fields, access, pos})
}

private fun parseDataField(cursor: TokenCursor, init: Map[String, TypeExpression]): (TokenCursor, Map[String, TypeExpression]) = {
  val (nameCursor, name) = cursor.next()

  if (name isNot TokenWord) {
    name.pos.fail("Expected field name")
  }

  val (colonCursor, colon) = nameCursor.next()

  if (colon isNot TokenSymbol || colon.value != ":") {
    colon.pos.fail("Expected data field type")
  }

  val (typeCursor, type) = parseType(colonCursor)

  val result = init.set(name.value, type)

  val (endCursor, maybeEnd) = typeCursor.next()

  if (maybeEnd isNot TokenSymbol) {
    maybeEnd.pos.fail("Expected end of data field declarations")
  }

  match (maybeEnd.value) {
    "," => return parseDataField(endCursor, result)
    "}" => return (endCursor, result)
    _ => maybeEnd.pos.fail("Expected end of data field declarations")
  }
}

private fun parseImplDeclare(cursor: TokenCursor, access: AccessModifier, pos: Position): (TokenCursor, ParseImplDeclare) = {
  val (baseCursor, baseToken) = cursor.next()

  if (baseToken isNot TokenWord) {
    baseToken.pos.fail("Expected base type for implementation")
  }

  val base = baseToken.value

  val maybeFor = baseCursor.curr()

  val (forCursor, forType) = if (maybeFor is TokenWord && maybeFor.value == "for") {
    val (forCursor, forType) = { baseCursor.skip() } .next()

    if (forType isNot TokenWord) {
      forType.pos.fail("Expected for type of implementation")
    }

    (forCursor, forType.value)
  } else {
    (baseCursor, null)
  }

  val (openCursor, openBracket) = forCursor.next()

  if (openBracket isNot TokenSymbol || openBracket.value != "{") {
    openBracket.pos.fail("Expected open bracket of implementation block")
  }

  val (finalCursor, funcs) = parseImplBody(openCursor, base, List.of())

  return (finalCursor, ParseImplDeclare{base, proto: forType, funcs, access, pos} )
}

private fun parseImplBody(cursor: TokenCursor, base: String, init: List[ParseFunctionDeclare]): (TokenCursor, List[ParseFunctionDeclare]) = {
  val (nextCursor, maybeAccess) = cursor.next()

  if (maybeAccess isNot TokenWord) {
    maybeAccess.pos.fail("Expected function declaration")
  }

  val (startCursor, access) = match (maybeAccess.value) {
    "private" => (nextCursor, Private)
    "internal" => (nextCursor, Internal)
    "protected" => (nextCursor, Protected)
    "public" => (nextCursor, Public)
    "fun" => (cursor, Internal)
    _ => maybeAccess.pos.fail("Expected function declaration")
  }

  val (funCursor, funToken) = startCursor.next()

  if (funToken isNot TokenWord || funToken.value != "fun") {
    funToken.pos.fail("Expected function declaration")
  }

  val (finalCursor, func) = parseFunctionDeclare(funCursor, access, funToken.pos)
  val result = init.add(func)

  val maybeEnd = finalCursor.curr()

  if (maybeEnd is TokenSymbol && maybeEnd.value == "}") {
    return (finalCursor.skip(), result)
  } else {
    return parseImplBody(finalCursor, base, result)
  }
}

private fun parseFunctionDeclare(cursor: TokenCursor, access: AccessModifier, pos: Position): (TokenCursor, ParseFunctionDeclare) = {
  val (finalCursor, functionStatement) = parseFunctionStatement(cursor, pos)

  return (finalCursor, ParseFunctionDeclare{func: functionStatement, access, pos})
}

private fun parseFunctionStatement(cursor: TokenCursor, pos: Position): (TokenCursor, ParseFunctionStatement) = {
  val (nameCursor, nameToken) = cursor.next()

  if (nameToken is TokenWord) {
    val name = nameToken.value

    val maybeBracket = nameCursor.curr()

    val (typeParamCursor, typeParams) = if (maybeBracket is TokenSymbol && maybeBracket.value == "[") {
      parseFunctionTypeParameters(nameCursor.skip(), List.of())
    } else {
      (nameCursor, List.of())
    }

    val (parensCursor, openParen) = typeParamCursor.next()

    if (openParen isNot TokenSymbol || openParen.value != "(") {
      openParen.pos.fail("Expected open ( of function declaration")
    }

    val maybeClose = parensCursor.curr()

    val (closeCursor, parameters) = if (maybeClose is TokenSymbol && maybeClose.value == ")") {
      (parensCursor.skip(), List.of())
    } else {
      parseFunctionParameters(parensCursor, List.of())
    }

    val (colonCursor, colon) = closeCursor.next()

    if (colon isNot TokenSymbol || colon.value != ":") {
      colon.pos.fail("Expected function result type declaration")
    }

    val (resultCursor, resultType) = parseType(colonCursor)
    val (equalsCursor, equals) = resultCursor.next()

    if (equals isNot TokenSymbol || equals.value != "=") {
      equals.pos.fail("Expected function body assignment")
    }

    val (bodyCursor, body) = parseExpression(equalsCursor)

    val args = parameters.map({ it => val (first, second) = it; first })
    val argTypes = parameters.map({ it => val (first, second) = it; second })

    val lambdaExp = ParseLambdaExp{args, body, argTypes, resultType, pos}

    return (bodyCursor, ParseFunctionStatement{name, generics: typeParams, body: lambdaExp, vararg: false, pos})
  } else {
    nameToken.pos.fail("Expected function name")
  }
}

private fun parseAssignmentStatement(cursor: TokenCursor, pos: Position): (TokenCursor, ParseStatement) = {
  val maybeDestructure = cursor.curr()

  match (maybeDestructure) {
    _ when maybeDestructure is TokenSymbol && maybeDestructure.value == "(" => {
      val (patternCursor, patterns) = parseDestructureTuplePatterns(cursor.skip(), List.of())

      val (equalsCursor, equals) = patternCursor.next()

      if (equals isNot TokenSymbol || equals.value != "=") {
        equals.pos.fail("Expected assignment = operator")
      }

      val (bodyCursor, body) = parseExpression(equalsCursor)

      return (bodyCursor, ParseDeconstructTupleStatement{base: body, names: patterns, pos})
    }
    _ when maybeDestructure is TokenSymbol && maybeDestructure.value == "{" => {
      val (patternCursor, patterns) = parseDestructureDataPatterns(cursor.skip(), List.of())

      val (equalsCursor, equals) = patternCursor.next()

      if (equals isNot TokenSymbol || equals.value != "=") {
        equals.pos.fail("Expected assignment = operator")
      }

      val (bodyCursor, body) = parseExpression(equalsCursor)

      return (bodyCursor, ParseDeconstructDataStatement{base: body, values: patterns, pos})
    }
    _ when maybeDestructure is TokenWord => return parseSingleAssignmentStatement(cursor, pos)
    _ => maybeDestructure.pos.fail("Expected assignment pattern")
  }
}

private fun parseSingleAssignmentStatement(cursor: TokenCursor, pos: Position): (TokenCursor, ParseAssignmentStatement) = {
  val (nameCursor, nameToken) = cursor.next()

  if (nameToken isNot TokenWord) {
    nameToken.pos.fail("Expected assignment identifier")
  }

  val name = nameToken.value

  val (maybeColonCursor, maybeColon) = nameCursor.next()

  val (typeCursor, type) = if (maybeColon is TokenSymbol && maybeColon.value == ":") {
    parseType(maybeColonCursor)
  } else {
    (nameCursor, null)
  }

  val (equalsCursor, equals) = typeCursor.next()

  if (equals isNot TokenSymbol || equals.value != "=") {
    equals.pos.fail("Expected assignment = operator")
  }

  val (bodyCursor, body) = parseExpression(equalsCursor)

  return (bodyCursor, ParseAssignmentStatement{name, declaredType: type, body, pos})
}

private fun parseDestructureTuplePatterns(cursor: TokenCursor, init: List[String]): (TokenCursor, List[String]) = {
  val (firstCursor, nameToken) = cursor.next()

  if (nameToken isNot TokenWord) {
    nameToken.pos.fail("Expected identifier in data destructure assignment")
  }

  val name = nameToken.value

  val result = init.add(name)

  val (endCursor, maybeEnd) = firstCursor.next()

  if (maybeEnd isNot TokenSymbol) {
    maybeEnd.pos.fail("Expected end of destructure tuple pattern")
  }

  match (maybeEnd.value) {
    "," => return parseDestructureTuplePatterns(endCursor, result)
    ")" => return (endCursor, result)
    _ => maybeEnd.pos.fail("Expected end of destructure tuple pattern")
  }
}

private fun parseDestructureDataPatterns(cursor: TokenCursor, init: List[(String, String)]): (TokenCursor, List[(String, String)]) = {
  val (firstCursor, nameToken) = cursor.next()

  if (nameToken isNot TokenWord) {
    nameToken.pos.fail("Expected identifier in data destructure assignment")
  }

  val name = nameToken.value

  val maybeColon = firstCursor.curr()

  val (baseCursor, baseName) = if (maybeColon is TokenSymbol && maybeColon.value == ":") {
    val (baseCursor, baseToken) = firstCursor.skip().next()

    if (baseToken isNot TokenWord) {
      baseToken.pos.fail("Expected identifier in data destructure assignment")
    } else {
      (baseCursor, baseToken.value)
    }
  } else {
    (firstCursor, name)
  }

  val result = init.add( (baseName, name) )

  val (endCursor, maybeEnd) = baseCursor.next()

  if (maybeEnd isNot TokenSymbol) {
    maybeEnd.pos.fail("Expected end of destructure data pattern")
  }

  match (maybeEnd.value) {
    "," => return parseDestructureDataPatterns(endCursor, result)
    "}" => return (endCursor, result)
    _ => maybeEnd.pos.fail("Expected end of destructure data pattern")
  }
}

private fun parseFunctionTypeParameters(cursor: TokenCursor, init: List[String]): (TokenCursor, List[String]) = {
  val (nextCursor, nextWord) = cursor.next()

  if (nextWord is TokenWord) {
    val result = init.add(nextWord.value)

    val (finalCursor, maybeEnd) = nextCursor.next()

    if (maybeEnd is TokenSymbol) {
      match (maybeEnd.value) {
        "]" => return (finalCursor, result)
        "," => return parseFunctionTypeParameters(finalCursor, result)
      }
    }
  }

  nextWord.pos.fail("Expected function type parameter declaration")
}

private fun parseFunctionParameters(cursor: TokenCursor, init: List[(String, TypeExpression)]): (TokenCursor, List[(String, TypeExpression)]) = {
  val (nextCursor, nextWord) = cursor.next()

  if (nextWord is TokenWord) {
    val name = nextWord.value

    val ( result, finalCursor, maybeEnd ) = if (name == "this") {
      // allow 'this' anytime, any where. Let the Typechecker enforce validity
      val result = init.add( (name, NamedTypeExp{name: 'This'}) )
      val (finalCursor, maybeEnd) = nextCursor.next();
      ( result, finalCursor, maybeEnd )
    } else {
      val (colonCursor, colon) = nextCursor.next()

      if (colon isNot TokenSymbol || colon.value != ":") {
        colon.pos.fail("Expected ':'")
      }

      val (typeCursor, type) = parseType(colonCursor)

      val result = init.add( (name, type) )

      val (finalCursor, maybeEnd) = typeCursor.next()

      ( result, finalCursor, maybeEnd )
    }

    if (maybeEnd is TokenSymbol) {
      match (maybeEnd.value) {
        ")" => return (finalCursor, result)
        "," => return parseFunctionParameters(finalCursor, result)
        _ => nextWord.pos.fail("Expected function parameter declaration")
      }
    }
  }

  nextWord.pos.fail("Expected function parameter declaration")
}

private fun parseExpression(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  return parseMatchExp(cursor)
}

private fun parseMatchExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeMatch = cursor.curr()

  if (maybeMatch is TokenWord && maybeMatch.value == "match") {
    val skipped = cursor.skip()
    val (openParenCursor, openParen) = skipped.next()

    if (openParen isNot TokenSymbol || openParen.value != "(") {
      openParen.pos.fail("Expected open paren after match")
    }

    val (baseCursor, base) = parseExpression(openParenCursor)

    val (closeParenCursor, closeParen) = baseCursor.next()

    if (closeParen isNot TokenSymbol || closeParen.value != ")") {
      closeParen.pos.fail("Expected close paren after match value")
    }

    val (openCursor, openBracket) = closeParenCursor.next()

    if (openBracket isNot TokenSymbol || openBracket.value != "{") {
      openBracket.pos.fail("Expected open bracket of match expression")
    }

    val (patternCursor, patterns) = parseMatchPattern(openCursor, List.of())

    return (patternCursor, ParseMatchExp{base, patterns, pos: maybeMatch.pos})
  } else {
    return parseIfExp(cursor)
  }
}

private fun parseMatchPattern(cursor: TokenCursor, init: List[ParseMatchPattern]): (TokenCursor, List[ParseMatchPattern]) = {
  val (baseCursor, base) = parseExpression(cursor)

  val maybeWhen = baseCursor.curr()

  val (guardCursor, guard) = if (maybeWhen is TokenWord && maybeWhen.value == "when") {
    parseExpression(baseCursor.skip())
  } else {
    (baseCursor, null)
  }

  val (arrowCursor, arrow) = guardCursor.next()

  if (arrow isNot TokenSymbol || arrow.value != "=>") {
    arrow.pos.fail("Expected arrow of match pattern")
  }

  val (bodyCursor, body) = parseExpression(arrowCursor)

  val result = init.add(ParseMatchPattern{base, guard, body, pos: { cursor.curr() }.pos})

  val maybeEnd = bodyCursor.curr()

  if (maybeEnd is TokenSymbol && maybeEnd.value == "}") {
    return (bodyCursor.skip(), result)
  } else {
    return parseMatchPattern(bodyCursor, result)
  }
}

private fun parseIfExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeIf = cursor.curr()

  if (maybeIf is TokenWord && maybeIf.value == "if") {
    val skipped = cursor.skip()
    val (openParenCursor, openParen) = skipped.next()

    if (openParen isNot TokenSymbol || openParen.value != "(") {
      openParen.pos.fail("Expected open paren after if")
    }

    val (conditionCursor, condition) = parseExpression(openParenCursor)

    val (closeParenCursor, closeParen) = conditionCursor.next()

    if (closeParen isNot TokenSymbol || closeParen.value != ")") {
      openParen.pos.fail("Expected close paren after if condition")
    }

    val (thenCursor, thenExp) = parseExpression(closeParenCursor)

    val maybeElse = thenCursor.curr()

    val (elseCursor, elseExp) = if (maybeElse is TokenWord && maybeElse.value == "else") {
      parseExpression(thenCursor.skip())
    } else {
      (thenCursor, null)
    }

    return (elseCursor, ParseIfExp{condition, thenExp, elseExp, pos: maybeIf.pos})
  } else {
    return parseReturnExp(cursor)
  }
}

private fun parseReturnExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeReturn = cursor.curr()

  return if (maybeReturn is TokenWord && maybeReturn.value == "return") {
    val (finalCursor, ex) = parseExpression(cursor.skip())

    (finalCursor, ParseReturnExp{ex, pos: maybeReturn.pos})
  } else {
    parseThrowExp(cursor)
  }
}

private fun parseThrowExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeThrow = cursor.curr()

  return if (maybeThrow is TokenWord && maybeThrow.value == "throw") {
    val (finalCursor, ex) = parseExpression(cursor.skip())

    (finalCursor, ParseThrowExp{ex, pos: maybeThrow.pos})
  } else {
    parseBinaryExp(cursor)
  }
}

private fun parseBinaryExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val start = parseIsExp
  val prod = parseBinaryExpSet(Set.of("*", "/"), start)
  val sum = parseBinaryExpSet(Set.of("+", "-"), prod)
  val compare = parseBinaryExpSet(Set.of(">", ">=", "<", "<="), sum)
  val equal = parseBinaryExpSet(Set.of("==", "!="), compare)
  val and = parseBinaryExpSet(Set.of("&&"), equal)
  val or = parseBinaryExpSet(Set.of("||"), and)
  return or(cursor)
}

private fun parseBinaryExpSet(ops: Set[String], next: {TokenCursor -> (TokenCursor, ParseExpression)}): {TokenCursor -> (TokenCursor, ParseExpression)} = {
  fun rec(cursor: TokenCursor, left: ParseExpression): (TokenCursor, ParseExpression) = {
    val maybeOp = cursor.curr()

    if (maybeOp is TokenSymbol && ops.contains(maybeOp.value)) {
      val (rightCursor, right) = next(cursor.skip())

      return rec(rightCursor, ParseBinaryOpExp{op: maybeOp.value, left, right, pos: maybeOp.pos})
    } else {
      return (cursor, left)
    }
  }

  return { it =>
    val (leftCursor, left) = next(it)

    rec(leftCursor, left)
  }
}

private val isKeywords: Set[String] = Set.of("is", "isNot")

private fun parseIsExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val (leftCursor, left) = parseAccessExp(cursor)

  val maybeIs = leftCursor.curr()

  if (maybeIs is TokenWord && isKeywords.contains(maybeIs.value)) {
    val (rightCursor, right) = parseAccessExp(leftCursor.skip())

    return (rightCursor, ParseBinaryOpExp{op: maybeIs.value, left, right, pos: maybeIs.pos})
  } else {
    return (leftCursor, left)
  }

}

private fun parseAccessExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  fun rec(leftCursor: TokenCursor, left: ParseExpression): (TokenCursor, ParseExpression) = {
    val maybeOp = leftCursor.curr()

    if (maybeOp is TokenSymbol && maybeOp.value == ".") {
      val (rightCursor, rightExp) = parseCall(leftCursor.skip())

      val newLeft = match (rightExp) {
        _ when rightExp is ParseIdentifierExp => ParseFieldAccessExp {base: left, name: rightExp.name, pos: maybeOp.pos }
        _ when rightExp is ParseCallExp => {
          val callRight = rightExp.func

          if (callRight isNot ParseIdentifierExp) {
            maybeOp.pos.fail("Expected identifier to right of access op")
          }

          ParseMethodCallExp { base: left, name: callRight.name, arguments: rightExp.arguments, typeArguments: rightExp.typeArguments, pos: maybeOp.pos }
        }
        _ when rightExp is ParseConstructExp => {
          val constructRight = rightExp.base

          if (constructRight isNot ParseIdentifierExp) {
            maybeOp.pos.fail("Expected identifier to right of access op")
          }

          val right = ParseFieldAccessExp{ base: left, name: constructRight.name, pos: maybeOp.pos }

          val newCall = rightExp{ base: right }

          newCall
        }
        _ => maybeOp.pos.fail("Expected identifier to right of access op")
      }

      return rec(rightCursor, newLeft)
    } else {
      return (leftCursor, left)
    }
  }

  val (leftCursor, left) = parseCall(cursor)
  return rec(leftCursor, left)
}


private fun parseCall(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val (callCursor, base) = parseConstruct(cursor)

  val maybeOpenBracket = callCursor.curr()

  val (genCursor, genArguments) = if (maybeOpenBracket is TokenSymbol && maybeOpenBracket.value == "[") {
    val (closeCursor, args) = parseTypeList(callCursor.skip())

    if (args.isEmpty()) {
      maybeOpenBracket.pos.fail("Expected type arguments")
    }

    val (finalCursor, closeBracket) = closeCursor.next()

    if (closeBracket is TokenSymbol && closeBracket.value == "]") {
      (finalCursor, args)
    } else {
      closeBracket.pos.fail("Expected end of type arguments")
    }
  } else {
    (callCursor, List.of())
  }

  val maybeOpen = genCursor.curr()

  if (maybeOpen is TokenSymbol && maybeOpen.value == "(") {
    val openCursor = genCursor.skip()
    val maybeClose = openCursor.curr()

    val (closeCursor, args) = if (maybeClose is TokenSymbol && maybeClose.value == ")") {
      (openCursor.skip(), List.of())
    } else {
      parseCallArguments(openCursor, List.of())
    }

    return (closeCursor, ParseCallExp{func: base, arguments: args, typeArguments: genArguments, pos: base.pos})
  } else {
    return (callCursor, base)
  }
}

private fun parseCallArguments(cursor: TokenCursor, init: List[ParseExpression]): (TokenCursor, List[ParseExpression]) = {
  val (nextCursor, next) = parseExpression(cursor)
  val result = init.add(next)

  val (closeCursor, maybeClose) = nextCursor.next()

  if (maybeClose is TokenSymbol) {
    match (maybeClose.value) {
      "," => return parseCallArguments(closeCursor, result)
      ")" => return (closeCursor, result)
      _ => maybeClose.pos.fail("Expected end of arguments to function call")
    }
  } else {
    maybeClose.pos.fail("Expected end of arguments to function call")
  }
}

private fun parseConstruct(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val (baseCursor, base) = parseUnaryExp(cursor)

  val (maybeBracketCursor, maybeBracket) = baseCursor.next()

  if (maybeBracket is TokenSymbol && maybeBracket.value == "{") {
    val maybeClose = maybeBracketCursor.curr()

    val (closeCursor, args) = if (maybeClose is TokenSymbol && maybeClose.value == "}") {
      (maybeBracketCursor.skip(), List.of())
    } else {
      parseConstructArgs(maybeBracketCursor, List.of())
    }

    return (closeCursor, ParseConstructExp{base, values: args, pos: base.pos})
  } else {
    return (baseCursor, base)
  }
}

private fun parseConstructArgs(cursor: TokenCursor, init: List[(String, ParseExpression)]): (TokenCursor, List[(String, ParseExpression)]) = {
  val (nameCursor, nameToken) = cursor.next()

  if (nameToken isNot TokenWord) {
    nameToken.pos.fail("Expected field name")
  }

  val name = nameToken.value

  val maybeColon = nameCursor.curr()

  val (bodyExp, body) = if (maybeColon is TokenSymbol && maybeColon.value == ":") {
    parseExpression(nameCursor.skip())
  } else {
    (nameCursor, ParseIdentifierExp{name, pos: nameToken.pos})
  }

  val result = init.add( (name, body) )

  val (endCursor, maybeEnd) = bodyExp.next()

  return if (maybeEnd is TokenSymbol) {
    match (maybeEnd.value) {
      "," => parseConstructArgs(endCursor, result)
      "}" => (endCursor, result)
      _ => maybeEnd.pos.fail("Expected end of construct")
    }
  } else {
    maybeEnd.pos.fail("Expected end of construct")
  }
}

private val unaryOps: Set[String] = Set.of("-", "!")

private fun parseUnaryExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeOp = cursor.curr()

  if (maybeOp is TokenSymbol && unaryOps.contains(maybeOp.value)) {
    val (bodyCursor, body) = parseExpression(cursor.skip())

    return (bodyCursor, ParseUnaryOpExp{op: maybeOp.value, ex: body, pos: maybeOp.pos})
  } else {
    return parseConstructTuple(cursor)
  }
}

private fun parseConstructTuple(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeParen = cursor.curr()

  if (maybeParen is TokenSymbol && maybeParen.value == "(") {
    val openParenCursor = cursor.skip()
    val maybeClose = openParenCursor.curr()

    val (closeCursor, args) = if (maybeClose is TokenSymbol && maybeClose.value == ")") {
      (openParenCursor.skip(), List.of())
    } else {
      parseConstructTupleArgs(openParenCursor, List.of())
    }

    return (closeCursor, ParseConstructTupleExp{values: args, pos: maybeParen.pos})
  } else {
    return parseParseBlockExp(cursor)
  }
}

private fun parseConstructTupleArgs(cursor: TokenCursor, init: List[ParseExpression]): (TokenCursor, List[ParseExpression]) = {
  val (bodyExp, body) = parseExpression(cursor)

  val result = init.add(body)

  val (endCursor, maybeEnd) = bodyExp.next()

  return if (maybeEnd is TokenSymbol) {
    match (maybeEnd.value) {
      "," => parseConstructTupleArgs(endCursor, result)
      ")" => (endCursor, result)
      _ => maybeEnd.pos.fail("Expected end of tuple construct")
    }
  } else {
    maybeEnd.pos.fail("Expected end of tuple construct")
  }
}

private fun parseParseBlockExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val maybeBracket = cursor.curr()

  return if (maybeBracket is TokenSymbol && maybeBracket.value == "{") {
    if (checkIsLambda(cursor.skip(), 1)) {
      parseLambdaExp(cursor.skip(), maybeBracket.pos)
    } else {
      val (bodyCursor, body) = parseBlockStatement(cursor.skip(), List.of())

      (bodyCursor, ParseBlockExp{body, pos: maybeBracket.pos})
    }
  } else {
    parseStringTemplate(cursor)
  }
}


private val isLambdaArrows: Set[String] = Set.of("->", "=>")

private fun parseLambdaExp(cursor: TokenCursor, pos: Position): (TokenCursor, ParseExpression) = {
  val maybeArrow = cursor.curr()

  val (paramCursor, parameters) = if (maybeArrow is TokenSymbol && isLambdaArrows.contains(maybeArrow.value)) {
    (cursor, List.of())
  } else {
    parseLambdaParameters(cursor, List.of())
  }

  val maybeTypeArrow = paramCursor.curr()

  val (resultCursor, resultType) = if (maybeTypeArrow is TokenSymbol && maybeTypeArrow.value == "->") {
    parseType(paramCursor.skip())
  } else {
    (paramCursor, null)
  }

  val (arrowCursor, arrowToken) = resultCursor.next()

  if (arrowToken isNot TokenSymbol || arrowToken.value != "=>") {
    arrowToken.pos.fail("Expected lambda expression arrow")
  }

  val (bodyCursor, body) = parseBlockStatement(arrowCursor, List.of())

  val args = parameters.map({ it => val (first, second) = it; first })
  val argTypes = parameters.map({ it => val (first, second) = it; second })

  return (bodyCursor, ParseLambdaExp{args, body: ParseBlockExp{body, pos}, argTypes, resultType, pos})
}

private fun parseLambdaParameters(cursor: TokenCursor, init: List[(String, TypeExpression)]): (TokenCursor, List[(String, TypeExpression)]) = {
  val (wordCursor, wordToken) = cursor.next()

  if (wordToken is TokenWord) {
    val name = wordToken.value

    val maybeColon = wordCursor.curr()

    val (typeCursor, type) = if (maybeColon is TokenSymbol && maybeColon.value == ":") {
      parseType(wordCursor.skip())
    } else {
      (wordCursor, null)
    }

    val result = init.add( (name, type) )

    val maybeEnd = typeCursor.curr()

    if (maybeEnd is TokenSymbol) {
      match (maybeEnd.value) {
        "->" => return (typeCursor, result)
        "=>" => return (typeCursor, result)
        ","=> return parseLambdaParameters(typeCursor.skip(), result)
      }
    }
  }

  wordToken.pos.fail("Expected lambda parameter")
}

private fun checkIsLambda(cursor: TokenCursor, depth: Int): Boolean = {
  val (nextCursor, nextToken) = cursor.next()

  val nextDepth = if (nextToken is TokenSymbol) {
    match (nextToken.value) {
      "{" => depth + 1
      "}" => if (depth - 1 == 0) return false else depth - 1
      "=>" => if (depth == 1) return true else depth
      _ => depth
    }
  } else {
    depth
  }

  return checkIsLambda(nextCursor, nextDepth)
}

private fun parseBlockStatement(cursor: TokenCursor, init: List[ParseStatement]): (TokenCursor, List[ParseStatement]) = {
  val start = cursor.curr()

  if (start is TokenSymbol && start.value == ";") {
    return parseBlockStatement(cursor.skip(), init)
  }

  if (start is TokenSymbol && start.value == "}") {
    return (cursor.skip(), init)
  }

  val (finalCursor, statement) = if (start is TokenWord) {
    match (start.value) {
      "debugger" => (cursor.skip(), ParseDebuggerStatement{pos: start.pos})
      "val" => parseAssignmentStatement(cursor.skip(), start.pos)
      "fun" => parseFunctionStatement(cursor.skip(), start.pos)
      "type" => parseTypeStatement(cursor.skip(), start.pos)
      "import" => parseImportStatement(cursor.skip(), start.pos)
      "return" => {
        val (returnCursor, returnEx) = parseExpression(cursor.skip())
        (returnCursor, ParseExpressionStatement{ex: ParseReturnExp{ex: returnEx, pos: start.pos}, pos: start.pos} )
      }
      "throw" => {
        val (throwCursor, throwEx) = parseExpression(cursor.skip())
        (throwCursor, ParseExpressionStatement{ex: ParseThrowExp{ex: throwEx, pos: start.pos}, pos: start.pos} )
      }
      _ => {
        val (exCursor, ex) = parseExpression(cursor)
        (exCursor, ParseExpressionStatement{ex, pos: start.pos})
      }
    }
  } else {
    val (exCursor, ex) = parseExpression(cursor)
    (exCursor, ParseExpressionStatement{ex, pos: start.pos})
  }

  val result = init.add(statement)

  return parseBlockStatement(finalCursor, result)
}

private fun parseStringTemplate(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val (leftCursor, left) = parseTermExp(cursor)

  if (left is ParseIdentifierExp) {
    val maybeString = leftCursor.curr()

    if (maybeString is TokenString) {
      return (leftCursor.skip(), parseStringTemplateWithPrefix(maybeString.value, maybeString.pos, left.name))
    }
  }

  return (leftCursor, left)
}

private fun parseTermExp(cursor: TokenCursor): (TokenCursor, ParseExpression) = {
  val (finalCursor, token) = cursor.next()
  val pos = token.pos

  val ex = match(token) {
    // TODO: support both floats and ints
    _ when token is TokenNumber => ParseNumberLiteralExp{value: token.value, pos}
    _ when token is TokenString => parseStringTemplateWithPrefix(token.value, pos, null)
    _ when token is TokenWord => {
      match (token.value) {
        "null" => ParseNullLiteralExp{pos}
        "true" => ParseBooleanLiteralExp{value: true, pos}
        "false" => ParseBooleanLiteralExp{value: false, pos}
        _ => ParseIdentifierExp{name: token.value, pos}
      }
    }
    _ => token.pos.fail("Expected expression")
  }

  return (finalCursor, ex)
}

fun parseType(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  return parseTypeTuple(cursor)
}

private fun parseTypeTuple(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  val maybeParen = cursor.curr()

  return if (maybeParen is TokenSymbol && maybeParen.value == "(") {
    val (nextCursor, result) = parseTypeList(cursor.skip())
    val (finalCursor, closeParen) = nextCursor.next()

    if (closeParen is TokenSymbol && closeParen.value == ")") {
      (finalCursor, TupleTypeExp{params: result})
    } else {
      closeParen.pos.fail("Expected end of Type parens")
    }
  } else {
    parseTypeUnion(cursor)
  }
}

private fun parseTypeUnion(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  val (leftCursor, left) = parseTypeIntersection(cursor)
  val (maybeOrCursor, maybeOr) = leftCursor.next()

  return if (maybeOr is TokenSymbol && maybeOr.value == "|") {
    val (rightCursor, right) = parseTypeUnion(maybeOrCursor)
    (rightCursor, makeUnionType(left, right) )
  } else {
    (leftCursor, left)
  }
}

private fun makeUnionType(left: TypeExpression, right: TypeExpression): TypeExpression = {
  if (left == right) {
    return left
  }

  UnionTypeExp { params: unwrapUnionType(left).concat(unwrapUnionType(right)) }
}

private fun unwrapUnionType(type: TypeExpression): Set[TypeExpression] = if (type is UnionTypeExp) type.params else Set.of(type)

private fun parseTypeIntersection(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  val (leftCursor, left) = parseTypeFunction(cursor)
  val (maybeOrCursor, maybeOr) = leftCursor.next()

  return if (maybeOr is TokenSymbol && maybeOr.value == "&") {
    val (rightCursor, right) = parseTypeIntersection(maybeOrCursor)
    (rightCursor, makeIntersectionType(left, right))
  } else {
    (leftCursor, left)
  }
}

private fun makeIntersectionType(left: TypeExpression, right: TypeExpression): TypeExpression = {
  if (left == right) {
    return left
  }

  IntersectionTypeExp { params: unwrapIntersectionType(left).concat(unwrapIntersectionType(right)) }
}

private fun unwrapIntersectionType(type: TypeExpression): Set[TypeExpression] = if (type is Intersection) type.params else Set.of(type)

private fun parseTypeFunction(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  val maybeCurly = cursor.curr()

  if (maybeCurly is TokenSymbol && maybeCurly.value == "{") {
    val firstCursor = cursor.skip()
    val maybeArrow = firstCursor.curr()

    if (maybeArrow is TokenSymbol && maybeArrow.value == "->") {
      return parseTypeFunctionResult(firstCursor.skip(), List.of())
    }

    val (nextCursor, parameters) = parseTypeList(firstCursor)
    val (arrowCursor, arrow) = nextCursor.next()

    if (arrow is TokenSymbol && arrow.value == "->") {
      return parseTypeFunctionResult(arrowCursor, parameters)
    } else {
      arrow.pos.fail("Expected arrow in function type declaration")
    }
  } else {
    return parseTypeGeneric(cursor)
  }
}

private fun parseTypeFunctionResult(cursor: TokenCursor, parameters: List[TypeExpression]): (TokenCursor, TypeExpression) = {
  val (nextCursor, resultType) = parseType(cursor)
  val (finalCursor, closeBracket) = nextCursor.next()

  if (closeBracket is TokenSymbol && closeBracket.value == "}") {
    return (finalCursor, FunctionTypeExp{params: parameters, generics: List.of(), resultType})
  } else {
    closeBracket.pos.fail("Expected close of function type")
  }
}

private fun parseTypeGeneric(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  val (firstCursor, base) = parseTypeIdentifier(cursor)
  val maybeBracket = firstCursor.curr()

  return if (maybeBracket is TokenSymbol && maybeBracket.value == "[") {
    val (nextCursor, parameters) = parseTypeList(firstCursor.skip())

    if (parameters.isEmpty()) {
      maybeBracket.pos.fail("Expected generic parameters")
    }

    val (finalCursor, closeBracket) = nextCursor.next()

    if (closeBracket is TokenSymbol && closeBracket.value == "]") {
      (finalCursor, GenericTypeExp{base, params: parameters})
    } else {
      closeBracket.pos.fail("Expected end of generic type declaration")
    }
  } else {
    (firstCursor, base)
  }
}

private fun parseTypeIdentifier(cursor: TokenCursor): (TokenCursor, TypeExpression) = {
  val (finalCursor, token) = cursor.next()

  if (token is TokenWord) {
    return (finalCursor, NamedTypeExp{name: token.value})
  } else {
    token.pos.fail("Expected type")
  }
}

private fun parseTypeList(cursor: TokenCursor): (TokenCursor, List[TypeExpression]) = {
  val (nextCursor, head) = parseType(cursor)

  return parseTypeListContinue(nextCursor, List.of(head))
}

private fun parseTypeListContinue(cursor: TokenCursor, init: List[TypeExpression]): (TokenCursor, List[TypeExpression]) = {
  val maybeComma = cursor.curr()

  if (maybeComma is TokenSymbol && maybeComma.value == ",") {
    val (nextCursor, nextType) = parseType(cursor.skip())
    return parseTypeListContinue(nextCursor, init.add(nextType))
  } else {
    return (cursor, init)
  }
}

