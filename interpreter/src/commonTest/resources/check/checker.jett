
import this/sweep.qualifiedAst.QualifiedAssignmentStatement
import this/sweep.qualifiedAst.QualifiedAtomDeclare
import this/sweep.qualifiedAst.QualifiedBinaryOpExp
import this/sweep.qualifiedAst.QualifiedBlockExp
import this/sweep.qualifiedAst.QualifiedBooleanLiteralExp
import this/sweep.qualifiedAst.QualifiedCallExp
import this/sweep.qualifiedAst.QualifiedCharLiteralExp
import this/sweep.qualifiedAst.QualifiedConstantDeclare
import this/sweep.qualifiedAst.QualifiedConstructExp
import this/sweep.qualifiedAst.QualifiedConstructTupleExp
import this/sweep.qualifiedAst.QualifiedDataDeclare
import this/sweep.qualifiedAst.QualifiedDebuggerStatement
import this/sweep.qualifiedAst.QualifiedDeclaration
import this/sweep.qualifiedAst.QualifiedDeconstructDataStatement
import this/sweep.qualifiedAst.QualifiedDeconstructTupleStatement
import this/sweep.qualifiedAst.QualifiedExpression
import this/sweep.qualifiedAst.QualifiedExpressionStatement
import this/sweep.qualifiedAst.QualifiedFieldAccessExp
import this/sweep.qualifiedAst.QualifiedFile
import this/sweep.qualifiedAst.QualifiedFunctionDeclare
import this/sweep.qualifiedAst.QualifiedFunctionStatement
import this/sweep.qualifiedAst.QualifiedIdentifierExp
import this/sweep.qualifiedAst.QualifiedIfExp
import this/sweep.qualifiedAst.QualifiedImplDeclare
import this/sweep.qualifiedAst.QualifiedImportDeclare
import this/sweep.qualifiedAst.QualifiedImportStatement
import this/sweep.qualifiedAst.QualifiedLambdaExp
import this/sweep.qualifiedAst.QualifiedMatchExp
import this/sweep.qualifiedAst.QualifiedMatchPattern
import this/sweep.qualifiedAst.QualifiedMethodCallExp
import this/sweep.qualifiedAst.QualifiedModule
import this/sweep.qualifiedAst.QualifiedNullLiteralExp
import this/sweep.qualifiedAst.QualifiedNumberLiteralExp
import this/sweep.qualifiedAst.QualifiedProtocolDeclare
import this/sweep.qualifiedAst.QualifiedReturnExp
import this/sweep.qualifiedAst.QualifiedStatement
import this/sweep.qualifiedAst.QualifiedStringLiteralExp
import this/sweep.qualifiedAst.QualifiedThrowExp
import this/sweep.qualifiedAst.QualifiedTypeDeclare
import this/sweep.qualifiedAst.QualifiedTypeStatement
import this/sweep.qualifiedAst.QualifiedUnaryOpExp

import this/check.typedAst.TypedAssignmentStatement
import this/check.typedAst.TypedAtomDeclare
import this/check.typedAst.TypedBinaryOpExp
import this/check.typedAst.TypedBlockExp
import this/check.typedAst.TypedBooleanLiteralExp
import this/check.typedAst.TypedCallExp
import this/check.typedAst.TypedCharLiteralExp
import this/check.typedAst.TypedConstantDeclare
import this/check.typedAst.TypedConstructExp
import this/check.typedAst.TypedConstructTupleExp
import this/check.typedAst.TypedDataDeclare
import this/check.typedAst.TypedDebuggerStatement
import this/check.typedAst.TypedDeclaration
import this/check.typedAst.TypedDeconstructDataStatement
import this/check.typedAst.TypedDeconstructTupleStatement
import this/check.typedAst.TypedExpression
import this/check.typedAst.TypedExpressionStatement
import this/check.typedAst.TypedFieldAccessExp
import this/check.typedAst.TypedFile
import this/check.typedAst.TypedFunctionDeclare
import this/check.typedAst.TypedFunctionStatement
import this/check.typedAst.TypedIdentifierExp
import this/check.typedAst.TypedIfExp
import this/check.typedAst.TypedImplDeclare
import this/check.typedAst.TypedImportDeclare
import this/check.typedAst.TypedImportStatement
import this/check.typedAst.TypedLambdaExp
import this/check.typedAst.TypedMatchExp
import this/check.typedAst.TypedMatchPattern
import this/check.typedAst.TypedMethodCallExp
import this/check.typedAst.TypedModule
import this/check.typedAst.TypedNullLiteralExp
import this/check.typedAst.TypedNumberLiteralExp
import this/check.typedAst.TypedProtocolDeclare
import this/check.typedAst.TypedReturnExp
import this/check.typedAst.TypedStatement
import this/check.typedAst.TypedStringLiteralExp
import this/check.typedAst.TypedThrowExp
import this/check.typedAst.TypedTypeDeclare
import this/check.typedAst.TypedTypeStatement
import this/check.typedAst.TypedUnaryOpExp

import this/sweep.dictionary.Dictionary

import this/type.typeExpression.QualifiedTypeExpression
import this/type.typeExpression.QualifiedNamedTypeExp
import this/type.typeExpression.QualifiedGenericTypeExp
import this/type.typeExpression.QualifiedFunctionTypeExp
import this/type.typeExpression.QualifiedTupleTypeExp
import this/type.typeExpression.QualifiedUnionTypeExp
import this/type.typeExpression.QualifiedIntersectionTypeExp

import this/type.typeExpression.applyIs
import this/type.typeExpression.applyIsNot
import this/type.typeExpression.superType


private data Scope {
  dict: Dictionary,
  types: Map[String, QualifiedTypeExpression],
  values: Map[String, QualifiedTypeExpression]
}

implement Scope {
  fun new(dict: Dictionary): Scope = Scope { dict, types: Map.of(), values: Map.of() }

  fun setType(this, name: String, typeExp: QualifiedTypeExpression): Scope = this { types: this.types.set(name, typeExp) }

  fun setValue(this, name: String, typeExp: QualifiedTypeExpression): Scope = this { values: this.values.set(name, typeExp) }

  fun importSymbol(this, name: String, symbol: QualifiedSymbol, pos: Position): Scope = {
    val importedType = this.dict.types.get(name);
    val importedValue = this.dict.values.get(name);

    if (importedType == null && importedValue == null) {
      pos.fail("Cannot import unknown value $name")
    }

    val exp = QualifiedNamedTypeExp { name: symbol };

    val withType = if (importedType != null) {
      this.setType(name,exp)
    } else {
      this
    };

    if (importedValue != null) {
      withType.setValue(name, exp)
    } else {
      withType
    }
  }
}

fun checkModule(mod: QualifiedModule, dict: Dictionary): TypedModule = {

  TypedModule {
    files: mod.files.entries().fold(Map.of(), { map, pair =>
      val (key, file) = pair;
      map.set(key, checkFile(file, dict))
    })
  }
}

private fun checkFile(file: QualifiedFile, dict: Dictionary): TypedFile = {
  val scope = Scope.new(dict);

  TypedFile {
    path: file.path,
    declarations: file.declarations.map({ dec => checkDeclaration(dec, scope) })
  }
}

private fun checkDeclaration(dec: QualifiedDeclaration, scope: Scope): TypedDeclaration = {
  match (dec) {
    _ when dec is QualifiedAtomDeclare => {
      val { name, access, pos } = dec;

      TypedAtomDeclare { name, access, pos }
    }
    _ when dec is QualifiedDataDeclare => {
      val { name, generics, body, access, pos } = dec;

      TypedDataDeclare { name, generics, body, access, pos }
    }
    _ when dec is QualifiedTypeDeclare => {
      val { type, access, pos } = dec;

      val (result) = checkTypeStatement(type, scope);

      TypedTypeDeclare { type: result, access, pos }
    }
    _ when dec is QualifiedFunctionDeclare => {
      val { func, access, pos } = dec;

      val (result) = checkFunctionStatement(func, scope);

      TypedFunctionDeclare { func: result, access, pos }
    }
    _ when dec is QualifiedImportDeclare => {
      val { statement, access, pos } = dec;

      val (result) = checkImportStatement(statement, scope);

      TypedImportDeclare { statement: result, access, pos }
    }
    _ when dec is QualifiedConstantDeclare => {
      val { assign, access, pos } = dec;

      val (result) = checkAssignmentStatement(assign, scope);

      TypedConstantDeclare { assign: result, access, pos }
    }
    _ when dec is QualifiedProtocolDeclare => {
      val { name, generics, funcs, access, pos } = dec;

      val result = funcs.map({ pair =>
        val (name, func) = pair;
        val { generics, params, result } = func;

        (name, TypedProtocolFunctionDeclare { generics, params, result })
      })

      TypedProtocolDeclare { name, generics, funcs: result, access, pos }
    }
    _ when dec is QualifiedImplDeclare => {
      val { base, proto, funcs: rawFuncs, access, pos } = dec;

      val funcs = rawFuncs.map({ dec =>
        val { func, access, pos } = dec;

        val (result) = checkFunctionStatement(func, scope);

        TypedFunctionDeclare { func: result, access, pos }
      })

      TypedImplDeclare { base, proto, funcs, access, pos }
    }
  }
}

private fun checkStatement(state: QualifiedStatement, scope: Scope): (TypedStatement, Scope) = {
  match (state) {
    _ when state is QualifiedExpressionStatement => checkExpressionStatement(state, scope)
    _ when state is QualifiedTypeStatement => checkTypeStatement(state, scope)
    _ when state is QualifiedFunctionStatement => checkFunctionStatement(state, scope)
    _ when state is QualifiedAssignmentStatement => checkAssignmentStatement(state, scope)
    _ when state is QualifiedImportStatement => checkImportStatement(state, scope)
    _ when state is QualifiedDeconstructDataStatement => checkDeconstructDataStatement(state, scope)
    _ when state is QualifiedDeconstructTupleStatement => checkDeconstructTupleStatement(state, scope)
    _ when state is QualifiedDebuggerStatement => (TypedDebuggerStatement { pos: state.pos }, scope)
  }
}

private fun checkTypeStatement(state: QualifiedTypeStatement, scope: Scope): (TypedTypeStatement, Scope) = {
  val { name, value, pos } = state;

  val result = TypedTypeStatement { name, value pos };
  val extendedScope = scope.setType(name, value);

  return (result, extendedScope);
}

private fun checkFunctionStatement(state: QualifiedFunctionStatement, scope: Scope): (TypedFunctionStatement, Scope) = {
  val { name, generics, vararg, body: rawBody, pos } = state;

  val funcType = QualifiedFunctionTypeExp { generics, vararg, params: rawBody.argTypes, result: rawBody.resultType };
  val (body, type) = checkLambdaExpression(rawBody, funcType, scope);
  val result = TypedFunctionStatement { name, generics, body, pos };

  return (result, scope.setValue(name, type));
}

private fun checkAssignmentStatement(state: QualifiedAssignmentStatement, scope: Scope): (TypedAssignmentStatement, Scope) = {
  val { name, declaredType, body: rawBody, pos } = state;

  val (body, type) = checkExpression(body, declaredType, scope);
  val result = TypedAssignmentStatement { name, declaredType: type, body, pos };

  return (result, scope.setValue(name, type));
}

private fun checkImportStatement(state: QualifiedImportStatement, scope: Scope): (TypedImportStatement, Scope) = {
  val { org, module, path, name, pos } = state;

  val result = TypedImportStatement { org, module, path, name, pos };
  val extendedScope = scope.importSymbol(name, QualifiedSymbol { org, module, path }, pos);

  return (result, extendedScope);
}

private fun core(name: String): QualifiedNamedTypeExp = {
  QualifiedNamedTypeExp {
    name: QualifiedSymbol { org: 'core', module: 'core', path: List.of(name) }
  }
}

private val nullType = core('Null');
private val booleanType = core('Boolean');
private val intType = core('Int');
private val floatType = core('Float');
private val stringType = core('String');
private val charType = core('Char');
private val listType = core('List');
private val nothingType = core('Nothing');
private val anyType = core('Any');

private val mathOps = Set.of(">", ">=", "<", "<=", "-", "+", "*", "/");
private val compareOps = Set.of("==", "!=");
private val typeOps = Set.of("is", "isNot");
private val boolOps = Set.of('&&', '||');
private val flowOps = typeOps.concat(boolOps);

private fun checkExpression(ex: QualifiedExpression, expectedType: QualifiedTypeExpression, scope: Scope): (TypedExpression, QualifiedTypeExpression, Scope) = {
  val (result, actualType, actualScope) = match (ex) {
    _ when ex is QualifiedNullLiteralExp => return (TypedNullLiteralExp { pos: ex.pos, type: expectedType }, nullType, scope)
    _ when ex is QualifiedBooleanLiteralExp => (TypedBooleanLiteralExp { value: ex.value, pos: ex.pos, type: booleanType }, booleanType, scope)
    _ when ex is QualifiedNumberLiteralExp => (TypedNumberLiteralExp { value: ex.value, pos: ex.pos, type: intType }, intType, scope)
    _ when ex is QualifiedStringLiteralExp => (TypedStringLiteralExp { value: ex.value, pos: ex.pos, type: stringType }, stringType, scope)
    _ when ex is QualifiedCharLiteralExp => (TypedCharLiteralExp { value: ex.value, pos: ex.pos, type: charType }, charType, scope)
    _ when ex is QualifiedIdentifierExp => {
      val { name, pos } = ex;

      val valueType = scope.values.get(name);

      if (valueType == null) {
        pos.fail("No such value $name found in scope");
      }

      (TypedIdentifierExp { name, pos, type: valueType }, valueType)
    }
    _ when ex is QualifiedBinaryOpExp => {
      val (left, right, actualType, actualScope) = match (ex.op) {
        _ when mathOps.contains(ex.op) => {
          val (left, _, leftScope) = checkExpression(ex.left, intType, scope);
          val (right, _, rightScope) = checkExpression(ex.right, intType, leftScope);

          (left, right, intType, rightScope)
        }
        _ when compareOps.contains(ex.op) => {
          val (left, _, leftScope) = checkExpression(ex.left, null, scope);
          val (right, _, rightScope) = checkExpression(ex.right, null, leftScope);

          (left, right, booleanType, rightScope)
        }
        // handles 'is', 'isNot', '&&' and '||'
        _ when flowOps.contains(ex.op) => {
          val (resultEx) = flowSensitiveAnalysis(ex, expectedType, scope);

          // any scope flow is discarded and we maintain the existing scope
          return (resultEx, booleanType, scope)
        }
        _ => ex.pos.fail("Unknown binary operator ${ex.op}")
      };

      scope.dict.isAssignable(actualType, expectedType, ex.pos);

      val result = TypedBinaryOpExp {
        op: ex.op,
        left,
        right,
        pos,
        type: actualType
      };

      (result, actualType, actualScope)
    }
    _ when ex is QualifiedUnaryOpExp => {
      match (ex.op) {
        _ when ex.op == '-' => {
          scope.dict.isAssignable(intType, expectedType, ex.pos);
          val (base) = checkExpression(ex.ex, intType, scope);

          return (base, scope)
        }
        _ when ex.op == '!' => {
          val (resultEx) = flowSensitiveAnalysis(ex, expectedType, scope);

          // any scope flow is discarded and we maintain the existing scope
          return (resultEx, booleanType, scope)
        }
        _ => ex.pos.fail("Unknown unary operator ${ex.op}")
      }
    }
    _ when ex is QualifiedBlockExp => {
      return checkBlockExpression(ex, expectedType, scope);
    }
    _ when ex is QualifiedFieldAccessExp => {
      val (base, baseType) = checkExpression(ex.base, expectedType, scope);

      val fieldType = scope.dict.fieldOf(baseType, ex.name, ex.pos);

      scope.dict.isAssignable(fieldType, expectedType, ex.pos);

      val result = TypedFieldAccessExp {
        base,
        name: ex.name,
        pos: ex.pos,
        type: fieldType
      };

      return (result, fieldType, scope)
    }
    _ when ex is QualifiedCallExp => {
      val (func, funcType) = checkExpression(ex.func, null, scope);

      if (funcType isNot QualifiedFunctionTypeExp) {
        ex.func.pos.fail("Attempt to call non-function")
      }



    }
    _ when ex is QualifiedIfExp => {
      val (condition, conditionalFlow) = flowSensitiveAnalysis(ex.condition, booleanType, scope);

      val (thenExp, thenType) = checkExpression(ex.thenEx, expectedType, conditionalFlow.whenTrue);

      val (elseEx, resultType, resultScope) = if (ex.elseEx == null) {
        val resultScope = if (thenType == nothingType) {
          conditionalFlow.whenFalse
        } else {
          scope
        };

        (null, thenType, resultScope)
      } else {
        val (elseEx, elseType) = checkExpression(ex.elseEx, expectedType, conditionalFlow.whenFalse);

        val (resultType, resultScope) = if (thenType == nothingType) {
          if (elseType == nothingType) {
            (nothingType, scope)
          } else {
            (elseType, conditionalFlow.whenFalse)
          }
        } else {
          if (elseType == nothingType) {
            (thenType, conditionalFlow.whenTrue)
          } else {
            (superType(thenType, elseType), scope)
          }
        };

        (elseEx, resultType, resultScope)
      }

      val result = TypedIfExp {
        condition,
        thenExp,
        elseEx,
        pos: ex.pos,
        type: resultType
      };

      return (result, resultType, resultScope);
    }
  };

  actualScope.dict.isAssignable(actualType, expectedType);
  return (result, actualType, actualScope);
}

data FlowSensitive {
  whenTrue: Scope,
  whenFalse: Scope
}

implement FlowSensitive {
  fun matching(scope: Scope): FlowSensitive = FlowSensitive { whenTrue: scope, whenFalse: scope }

  fun flip(this): FlowSensitive = FlowSensitive { whenTrue: this.whenFalse, whenFalse: this.whenTrue }
}

private fun flowSensitiveAnalysis(ex: QualifiedExpression, expectedType: QualifiedTypeExpression, scope: Scope): (TypedExpression, QualifiedTypeExpression, FlowSensitive) = {
  if (ex is QualifiedBinaryOpExp) {
    val { op, pos } = ex;

    match (op) {
      _ when typeOps.contains(op) => {
        scope.dict.isAssignable(booleanType, expectedType, pos);
        return doIsTypeAssertion(ex, scope)
      }
      "&&" => {
        scope.dict.isAssignable(booleanType, expectedType, pos);

        val (left, leftFlow) = flowSensitiveAnalysis(ex.left, booleanType, scope);
        val (right, rightFlow) = flowSensitiveAnalysis(ex.right, booleanType, leftFlow.whenTrue);

        val flow = rightFlow { whenFalse: scope }

        val response = TypedBinaryOpExp {
          op,
          left,
          right,
          pos,
          type: booleanType
        };

        return (response, booleanType, flow)
      }
      "||" => {
        scope.dict.isAssignable(booleanType, expectedType, pos);

        val (left, leftFlow) = flowSensitiveAnalysis(ex.left, booleanType, scope);
        val (right, rightFlow) = flowSensitiveAnalysis(ex.right, booleanType, leftFlow.whenFalse);

        val flow = rightFlow { whenTrue: scope }

        val response = TypedBinaryOpExp {
          op,
          left,
          right,
          pos,
          type: booleanType
        };

        return (response, booleanType, flow)
      }
      _ => ex
    }
  }

  if (ex is QualifiedUnaryOpExp && ex.op == '!') {
    scope.dict.isAssignable(booleanType, expectedType, pos);
    val (base, _, flow) = flowSensitiveAnalysis(ex.ex, booleanType, scope);

    return (TypedUnaryOpExp { op: '!', ex: base, pos: ex.pos, type: booleanType }, flow.flip())
  }

  // nothing special, check like a normal expression
  val (resultEx, resultType, resultScope) = checkExpression(ex, expectedType, scope)

  return (resultEx, resultType, FlowSensitive.matching(resultScope));
}

private fun doIsTypeAssertion(ex: QualifiedBinaryOpExp, scope: Scope): (TypedExpression, QualifiedTypeExpression, FlowSensitive) = {
  val (left, leftType, leftScope) = checkExpression(ex.left, null, scope);

  if (ex.right isNot QualifiedIdentifierExp) {
    ex.right.pos.fail("Expected type identifier to the right of 'is' and 'isNot' operators.")
  }

  val right = scope.types.get(ex.right.name);

  match (right) {
    null => ex.right.pos.fail("No such type ${ex.right.name} found in scope")
    _ when right is QualifiedNamedTypeExp => {
      val fullTypeInfo = scope.dict.types.get(right.name);

      match (fullTypeInfo) {
        null => ex.right.pos.fail("Type lookup failed, something has gone horribly wrong").
        _ when fullTypeInfo is DataType || fullTypeInfo is AtomType => {
          val result = TypedBinaryOpExp {
            op: ex.op,
            left,
            right: TypedIdentifierExp { name: ex.right.name, pos: ex.right.pos, type: right },
            pos: ex.pos,
            type: booleanType
          };

          // TODO: For now we're only flowing on a single identifier, in future flowing on a chain would be useful
          val flow = if (left is TypedIdentifierExp) {
            val name = left.name;

            val flow = FlowSensitive {
              whenTrue: scope.setValue(name, applyIs(left.type, right)),
              whenFalse: scope.setValue(name, applyIsNot(left.type, right))
            };

            if (ex.op == 'is') {
              flow
            } else {
              flow.flip()
            }
          } else {
            FlowSensitive.matching(scope)
          }

          return (result, booleanType, flow)
        }
        _ => ex.right.pos.fail("Only atom and data types can be checked with 'is' or 'isNot' operators. '${ex.right.name}' is neither.")
      }
    }
    _ => ex.right.pos.fail("Only atom and data types can be checked with 'is' or 'isNot' operators. '${ex.right.name}' is neither.")
  }
}

private fun checkFunctionCall(func: QualifiedFunctionTypeExp, arguments: List[QualifiedExpression], typeArguments: List[QualifiedTypeExpression], pos: Position, scope: Scope) = {

  if (typeArguments != null && typeArguments.size > func.generics.size) {
    pos.fail("Function accepts ${func.generics.size} type parameters but found ${typeArguments.size}")
  }

  val scopeWithGenerics = func.generics.zipLeft(if (typeArguments == null) List.of() else typeArguments).fold(scope, { pair =>
    // TODO: Someday when we have bounds, apply those bounds here
    val (name, rawType) = pair;
    val actualType = if (rawType == null) anyType else rawType;

    scope.setType(name, actualType)
  });

  fun checkEachArgument(params: List[QualifiedTypeExpression], arguments: List[QualifiedExpression], scope: Scope): (List[TypedExpression], Scope) = {
    if (func.vararg && params.size == 1) {
      // special case for var args

      val param = params.head();

      if (param isNot QualifiedGenericTypeExp) {
        pos.fail("Cannot call vararg function who's final argument is not a List")
      }

      if (param.base != listType) {
        pos.fail("Cannot call vararg function who's final argument is not a List")
      }

      // the actual parameter type we need to check against all remaining arguments
      val listOf = param.params.head();

      val typedArguments = arguments.map({ arg =>
        val (typed, actual) = checkExpression(arg, listOf, scope.scope);


      })
    }
  }
}

