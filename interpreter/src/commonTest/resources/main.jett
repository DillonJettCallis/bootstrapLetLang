import core/io.File



fun main(args: List[String]): Unit = {
  if (args.isEmpty()) {
    println('Invalid arguments. Expected just one source file for now.')
  } else {
    val fileName = args.head()
    val tokens = lex(fileName, File.fromPath(fileName).readText())
    println("Tokens: ${tokens}")
  }
}

// org

atom PublicAccess
atom ProtectedAccess
atom InternalAccess
atom PrivateAccess

type AccessModifier = PublicAccess | ProtectedAccess | InternalAccess | PrivateAccess

data TypeRef = { package: String, module: String, name: String }
data FunctionRef = { package: String, module: String, name: String }
data ModuleRef = { name: String, types: List[Type], functions: List[FunctionRef] }
data PackageRef = { name: String, modules: List[Module] }
data ApplicationRef { name: String, packages: List[Package] }

// types

atom BooleanType
atom IntType
atom CharType
atom ListType
atom MapType

type PrimitiveType = BooleanType | IntType | CharType | ListType | MapType

atom UnknownType
data NamedType = { name: String }
type DataType = TypeRef | PrimitiveType
data GenericType = { base: Type, params: List[Type] }
data FunctionType = { args: List[Type], result: Type }
data GenericFunctionType = { typeArgs: Map[String, TypeParameter], args: List[Type], result: Type }
data TypeParameter = { bound: Type }
data UnionType = { union: List[Type] }
data TupleType = { types: List[Type] }

type Type = UnknownType | DataType | KnownType | GenericType | FunctionType | GenericFunctionType | TypeParameter | UnionType | TupleType

// parser
data MatchPattern = { base: Expression, guard: Expression, body: Expression, pos: Position }

data BooleanLiteralExp = { value: Boolean, pos: Position }
data StringLiteralExp = { value: String, pos: Position }
data NumberLiteralExp = { raw: String, pos: Position }
data IdentifierExp = { name: String, type: Type, pos: Position }
data BlockExp = { statements: List[Statement], pos: Position }
data CallExp = { func: Expression, args: List[Expression], pos: Position }
data LambdaExp = { args: List[(String, Type)], resultType: Type, pos: Position }
data IfExp = { condition: Expression, thenBlock: Expression, elseBlock: Expression?, pos: Position }
data ReturnExp { result: Expression, pos: Position }
data ConstructDataExp = { values: List[(String, Expression)], pos: Position }
data ConstructTupleExp = { values: List[Expression], pos: Position }
data MutateExp = { base: Expression, assignments: List[(String, Expression)], pos: Position }
data MatchExp = { base: Expression, patterns: List[MatchPattern] }

type Expression = StringLiteralExp
  | NumberLiteralExp
  | IdentifierExp
  | BlockExp
  | CallExp
  | LambdaExp
  | IfExp
  | ReturnExp
  | ConstructTupleExp
  | MutateExp
  | MatchExp

data DataDeclare = { name: String, fields: Map[String, Type], pos: Position }
data ImplementationDeclare = { baseType: String, functions: Map[String, FunctionDeclare], pos: Position }
data TypeDeclare = { name: String, expression: Type, pos: Position }
data DeconstructTupleDeclare = { names: List[String], pos: Position }
data ValueDeclare = { name: String, value: Expression, pos: Position }
data FunctionDeclare = { name: String, access: AccessModifier, value: LambdaExp }
data ImportDeclare = { package: String, module: String, pos: Position }
data ConstDeclare = { access: AccessModifier, assignment: ValueDeclare }

// can appear in a block
type Statement = Expression | TypeDeclare | ValueDeclare | FunctionDeclare | ImportDeclare | DeconstructTupleDeclare

// can appear at the top of a file
type Declaration = DataDeclare | ImplementationDeclare | TypeDeclare | ConstDeclare | FunctionDeclare | ImportDeclare

data ModuleDeclare = { name: String, declarations: Map[String, Declaration] }


private data ParseCursor = { tokens: List[Token], index: Int }

implement ParseCursor {

  fun isEmpty(): Boolean = tokens.size < index
  fun isNotEmpty(): Boolean = tokens.size >= index
  fun curr(): Char = raw.get(index)
  fun prev(): Char = raw.get(index - 1)
  fun peek(): Char = raw.get(index + 1)
  fun skip(): StringCursor = this{index: index + 1}
  fun next(): (StringCursor, Char) = {
    val next = skip()
    (next, next.curr())
  }

}

fun parseModule(name: String, tokens: List[Token]): ModuleDeclare = {
  val cursor = ParseCursor{tokens, index: -1}

  val declarations = parseDeclarations(cursor, List.of(), null)
    .keyBy({ dec => dec.name })

  ModuleDeclare{name, declarations}
}

private fun parseDeclarations(cursor: ParseCursor, declarations: List[Declaration], access: AccessModifier): List[Declaration] = {
  if (cursor.isEmpty) {
    declarations
  } else {
    val (nextCursor, nextToken) = cursor.next()

    if (nextToken is TokenWord) {
      match (nextToken.value) {
        'fun' =>
        'data' =>
        'implement' =>
        'type' =>
        'val' => declarations.add(ConstDeclare{access, assignment: parseAssignment(nextCursor)})

        'private' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, PrivateAccess) else throw Error.new('use of multiple access modifier')
        'protected' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, ProtectedAccess) else throw Error.new('use of multiple access modifier')
        'internal' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, InternalAccess) else throw Error.new('use of multiple access modifier')
        'public' => if (defaultAccess == null) parseDeclarations(nextCursor, declarations, PublicAccess) else throw Error.new('use of multiple access modifier')
      }
    } else {
      throw Error.new('Syntax error: Expected word but found $next')
    }
  }
}

private fun parseStatement(cursor: ParseCursor): Statement {

}

private fun parseExpression(cursor: ParseCursor): Expression {

}

/**
 * Assume 'val' has already been parsed
 */
private fun parseAssignment(cursor: ParseCursor): ValueDeclare = {
  val pos = cursor.curr().pos
  val (nameCursor, nameToken) = cursor.next()

  if (nameToken is TokenWord) {
    val name = nameToken
    val (equalsCursor, equalsToken) = nameCursor.next()

    if (equalsToken is TokenSymbol && equalsToken.value == '=') {
      val expression = parseExpression(equalsCursor)

      return ValueDeclare{name, expression, pos}
    } else {
      equalsToken.pos.fail("Expected '=', found ${equalsToken.value}")
    }

  } else {
    nameToken.pos.fail('Expected assignment identifier')
  }
}

/**
 * Assume 'fun' has already been parsed
 */
private fun parseFunction(cursor: ParseCursor): FunctionDeclare = {
  val pos = cursor.curr().pos
  val (maybeGenericsCursor, maybeGenericsToken) = cursor.next()

  if (maybeGenericsToken is TokenSymbol && maybeGenericsToken.value == '[') {

  }
}

// lexer
private data StringCursor = { raw: String, index: Int, pos: Position }

implement StringCursor {

  fun isEmpty(): Boolean = raw.size < index
  fun isNotEmpty(): Boolean = raw.size >= index
  fun curr(): Char = raw.getCharAt(index)
  fun prev(): Char = raw.getCharAt(index - 1)
  fun peek(): Char = raw.getCharAt(index + 1)
  fun skip(): StringCursor = if (index == -1) this{index: index + 1} else this{index: index + 1, pos: pos.increment(curr())}
  fun next(): (StringCursor, Char) = {
    val next = skip()
    (next, next.curr())
  }

}

data Position = { line: Int, col: Int, src: String }

implement Position {
  fun increment(next: Char): Position = if (next == char'\n') this{line: line + 1, col: 0} else this{col: col + 1}
  fun fail(message: String): Nothing = throw Error.new("$message at ${this.line}:${this.col} in ${this.src}")
}

data TokenWord = { value: String, pos: Position }
data TokenSymbol = { value: String, pos: Position }
data TokenString = { value: String, pos: Position }
data TokenNumber = { value: String, pos: Position }

type Token = TokenWord | TokenSymbol | TokenString | TokenNumber

private val lowerCase = 'abcdefghijklmnopqrstuvwxyz'
private val upperCase = lowerCase.toUpperCase()
private val letters = lowerCase.append(upperCase)
private val digitStart = '0123456789'
private val digitContinue = digitStart.append('.')
private val wordStart = letters
private val wordContinue = letters.append(digitStart)
private val quoteChars = "'\"`"
private val whitespace = '\s\t\r\n'
private val lineComment = '//'
private val blockCommentStart = '/*'
private val blockCommentEnd = '*/'
private val singletonSymbols = '({[]})_,;' // these symbols are always alone. They can start but never continue
private val mergedSymbols = '=<>!-+/*:.&|' // these symbols merge with one another to form compound symbols
private val symbolStart = mergedSymbols.append(singletonSymbols)
private val symbolEnd = mergedSymbols

fun lex(src: String, raw: String): List[Token] = {
  val src = StringCursor{ raw, index: -1, pos: Position{ line: 1, col: 1, src } }

  muncher(src, List.of())
}

private fun muncher(src: StringCursor, result: List[Token]): List[Token] = {
  if (src.isEmpty()) return result

  val (nextCursor, nextChar) = src.next()

  match (nextChar) {
    // checking for comments, both block and line
    char'/' when nextCursor.isNotEmpty() && '/*'.contains(nextCursor.peek()) => {
      match (nextCursor.peek()) {
        char'/' => return muncher(munchLineComment(nextCursor), result)
        char'*' => return muncher(munchBlockComment(nextCursor), result)
      }
    }
    // check for number. Do not bother with making sure there is at most one decimal point yet.
    _ when digitStart.contains(nextChar) => {
      val (finalCursor, value) = munchDigit(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenWord {value, pos: nextCursor.pos }))
    }
    // lex any words
    _ when wordStart.contains(nextChar) => {
      val (finalCursor, value) = munchWord(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenNumber {value, pos: nextCursor.pos }))
    }
    // lex strings of any quote type
    _ when quoteChars.contains(nextChar) => {
      val (finalCursor, value) = munchString(nextCursor, "", nextChar)

      return muncher(finalCursor, result.add(TokenString{ value, pos: nextCursor.pos }))
    }
    // lex symbols
    _ when symbolStart.contains(nextChar) => {
      val (finalCursor, value) = munchSymbol(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenSymbol{ value, pos: nextCursor.pos }))
    }
    // handle whitespace
    _ when whitespace.contains(nextChar) => {
      return muncher(nextCursor, result)
    }
    _ => throw Error.new('Unexpected character $nextChar')
  }
}

private fun munchDigit(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, digitContinue)

private fun munchWord(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, wordContinue)

private fun munchSymbol(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, symbolEnd)

private fun munchContinuation(src: StringCursor, working: String, continuation: String): (StringCursor, String) = {
  val (nextCursor, nextChar) = src.next()

  if (continuation.contains(nextChar)) {
    // tail recursion
    munchContinuation(nextCursor, working.append(nextChar), continuation)
  } else {
    (src, working)
  }
}

/**
 * Munch the string, looking for the openType.
 * Do NOT process escapes or interpolation but DO allow escaped chars to pass through.
 */
private fun munchString(src: StringCursor, working: String, openType: Char): (StringCursor, String) = {
  val (nextCursor, nextChar) = src.next()

  // there is one close quote, maybe we are at the end
  match (nextChar) {
    openType => (nextCursor, working)
    char'\\' => { // something is escaped. Don't look at it, just pass both along no matter what.
      val (final, escapedChar) = nextCursor.next()

      munchString(final, working.append(nextChar).append(escapedChar), openType)
    }
    _ => munchString(nextCursor, working.append(nextChar), openType)
  }
}

private fun munchLineComment(src: StringCursor): StringCursor = {
  doUntil(src, { cur => cur.skip() } , { it => it.curr() == char'\n' })
}

private fun munchBlockComment(src: StringCursor): StringCursor = {
  doUntil(src, { cur => cur.skip() } , { it => it.curr() == char'*' && it.isNotEmpty() && it.peek() == char'/' })
}

private fun doUntil[Item](init: Item, action: { Item -> Item }, test: { Item -> Boolean }): Item =
  if (test(init)) init else doUntil(action(init), action, test)




