
private data StringCursor = { raw: String, index: Int, pos: Position }

implement StringCursor {

  fun isEmpty(): Boolean = this.index + 1 >= this.raw.size
  fun isNotEmpty(): Boolean = !this.isEmpty()
  fun curr(): Char = this.raw.getCharAt(this.index)
  fun prev(): Char = this.raw.getCharAt(this.index - 1)
  fun peek(): Char = this.raw.getCharAt(this.index + 1)
  fun skip(): StringCursor = if (this.index == -1) this{index: this.index + 1} else this{index: this.index + 1, pos: this.pos.increment(this.curr())}
  fun next(): (StringCursor, Char) = {
    val next = this.skip()
    (next, next.curr())
  }

}

data Position = { line: Int, col: Int, src: String }

implement Position {
  fun increment(next: Char): Position = if (next == char'\n') this{line: this.line + 1, col: 0} else this{col: this.col + 1}
  fun fail(message: String): Nothing = throw Error.new("$message at ${this.line}:${this.col} in ${this.src}")
}

data TokenWord = { value: String, pos: Position }
data TokenSymbol = { value: String, pos: Position }
data TokenString = { value: String, pos: Position }
data TokenNumber = { value: String, pos: Position }

type Token = TokenWord | TokenSymbol | TokenString | TokenNumber

private val lowerCase = 'abcdefghijklmnopqrstuvwxyz'
private val upperCase = lowerCase.toUpperCase()
private val letters = "_$lowerCase$upperCase"
private val digitStart = '0123456789'
private val digitContinue = digitStart.append('.')
private val wordStart = letters
private val wordContinue = letters.append(digitStart)
private val quoteChars = "'\"`"
private val whitespace = '\s\t\r\n'
private val lineComment = '//'
private val blockCommentStart = '/*'
private val blockCommentEnd = '*/'
private val singletonSymbols = '({[]}),;' // these symbols are always alone. They can start but never continue
private val mergedSymbols = '=<>!-+/*:.&|' // these symbols merge with one another to form compound symbols
private val symbolStart = mergedSymbols.append(singletonSymbols)
private val symbolEnd = mergedSymbols

fun lex(src: String, raw: String): List[Token] = {
  val src = StringCursor{ raw, index: -1, pos: Position{ line: 1, col: 1, src } }

  muncher(src, List.of())
}

private fun muncher(src: StringCursor, result: List[Token]): List[Token] = {
  if (src.isEmpty()) return result

  val (nextCursor, nextChar) = src.next()

  match (nextChar) {
    // checking for comments, both block and line
    char'/' when nextCursor.isNotEmpty() && '/*'.contains(nextCursor.peek()) => {
      match (nextCursor.peek()) {
        char'/' => return muncher(munchLineComment(nextCursor), result)
        char'*' => return muncher(munchBlockComment(nextCursor), result)
      }
    }
    // check for number. Do not bother with making sure there is at most one decimal point yet.
    _ when digitStart.contains(nextChar) => {
      val (finalCursor, value) = munchDigit(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenWord {value, pos: nextCursor.pos }))
    }
    // lex any words
    _ when wordStart.contains(nextChar) => {
      val (finalCursor, value) = munchWord(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenNumber {value, pos: nextCursor.pos }))
    }
    // lex strings of any quote type
    _ when quoteChars.contains(nextChar) => {
      val (finalCursor, value) = munchString(nextCursor, "", nextChar)

      return muncher(finalCursor, result.add(TokenString{ value, pos: nextCursor.pos }))
    }
    // lex symbols
    _ when symbolStart.contains(nextChar) => {
      val (finalCursor, value) = munchSymbol(nextCursor, nextChar.toString())

      return muncher(finalCursor, result.add(TokenSymbol{ value, pos: nextCursor.pos }))
    }
    // handle whitespace
    _ when whitespace.contains(nextChar) => {
      return muncher(nextCursor, result)
    }
    _ => src.pos.fail('Unexpected character $nextChar')
  }
}

private fun munchDigit(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, digitContinue)

private fun munchWord(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, wordContinue)

private fun munchSymbol(src: StringCursor, working: String): (StringCursor, String) = munchContinuation(src, working, symbolEnd)

private fun munchContinuation(src: StringCursor, working: String, continuation: String): (StringCursor, String) = {
  val (nextCursor, nextChar) = src.next()

  if (continuation.contains(nextChar)) {
    // tail recursion
    munchContinuation(nextCursor, working.append(nextChar), continuation)
  } else {
    (src, working)
  }
}

/**
 * Munch the string, looking for the openType.
 * Do NOT process escapes or interpolation but DO allow escaped chars to pass through.
 */
private fun munchString(src: StringCursor, working: String, openType: Char): (StringCursor, String) = {
  val (nextCursor, nextChar) = src.next()

  // there is one close quote, maybe we are at the end
  match (nextChar) {
    openType => (nextCursor, working)
    char'\\' => { // something is escaped. Don't look at it, just pass both along no matter what.
      val (final, escapedChar) = nextCursor.next()

      munchString(final, "$working$nextChar$escapedChar", openType)
    }
    _ => munchString(nextCursor, working.append(nextChar), openType)
  }
}

private fun munchLineComment(src: StringCursor): StringCursor = {
  doUntil(src, { cur => cur.skip() } , { it => it.curr() == char'\n' })
}

private fun munchBlockComment(src: StringCursor): StringCursor = {
  doUntil(src, { cur => cur.skip() } , { it => it.curr() == char'*' && it.isNotEmpty() && it.peek() == char'/' })
}

private fun doUntil[Item](init: Item, action: { Item -> Item }, test: { Item -> Boolean }): Item =
  if (test(init)) init else doUntil(action(init), action, test)




